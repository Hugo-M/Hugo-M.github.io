---
title: 变量的析构赋值
date: 2018-03-08 22:42:37
tags: ES6
---
ES6 允许按照**一定模式**，从**数组**和**对象**中提取值，对变量进行赋值，这被称为解构（Destructuring）。

### 数组的解构赋值
```js
let [foo, [[bar], baz]] = [1, [[2], 3]];
foo // 1
bar // 2
baz // 3

let [ , , third] = ["foo", "bar", "baz"];
third // "baz"

let [head, ...tail] = [1, 2, 3, 4];
head // 1
tail // [2, 3, 4]

let [x, y, ...z] = ['a'];
x // "a"
y // undefined
z // []

let [x, y, z] = new Set(['a', 'b', 'c']);
x // "a"
```
如果解构不成功，变量的值就等于undefined。解构赋值允许指定默认值。
```js
let [x, y = 'b'] = ['a']; // x='a', y='b'
let [x = 1] = [undefined]; // x = 1
let [x = 1] = [null]; // x = null
```
上面代码中，如果一个数组成员是`null`，默认值就不会生效，因为`null`不严格等于`undefined`。

<!-- more -->
### 对象的解构赋值
对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。
```js
let { bar, foo } = { foo: "aaa", bar: "bbb" };
foo // "aaa"
bar // "bbb"

let { baz } = { foo: "aaa", bar: "bbb" };
baz // undefined
```
下面代码中，`foo`是匹配的模式，`baz`才是变量。真正被赋值的是变量`baz`，而不是模式`foo`。
```js
let { foo: baz } = { foo: 'aaa', bar: 'bbb' };
baz // "aaa"

let obj = { first: 'hello', last: 'world' };
let { first: f, last: l } = obj;
f // 'hello'
l // 'world'
```
与数组一样，解构也可以用于嵌套结构的对象。
```js
let obj = {
  p: [
    'Hello',
    { y: 'World' }
  ]
};

let { p: [x, { y }] } = obj;
x // "Hello"
y // "World"
```
注意，这时`p`是模式，不是变量，因此不会被赋值。要`p`作为变量赋值，可以写成下面这样。
```js
let { p, p: [x, { y }] } = obj;
x // "Hello"
y // "World"
p // ["Hello", {y: "World"}]
```
下面是嵌套赋值的例子。
```js
let obj = {};
let arr = [];

({ foo: obj.prop, bar: arr[0] } = { foo: 123, bar: true });

obj // {prop:123}
arr // [true]
```
对象的解构也可以指定默认值。默认值生效的条件是，对象的属性值严格等于`undefined`。
```js
var {x, y = 5} = {x: 1};
x // 1
y // 5

var {x = 3} = {x: null};
x // null
```
如果要将一个已经声明的变量用于解构赋值，必须非常小心。
```js
// 错误的写法, JavaScript 引擎会将{x}理解成一个代码块
let x;
{x} = {x: 1};

// 正确的写法
let x;
({x} = {x: 1});
```
对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。
```js
let { log, sin, cos } = Math;
```
### 字符串的解构赋值
字符串也可以解构赋值。此时，字符串被转换成了一个类似数组的对象。
```js
const [a, b, c, d, e] = 'hello';
a // 'h'

let {length : len} = 'hello'; // 类似数组的对象都有一个length属性
len // 5
```
### 函数参数的解构赋值
```js
function move({x = 0, y = 0} = {}) {
  return [x, y];
}
move({x: 3, y: 8}); // [3, 8]
move({x: 3}); // [3, 0]
move({}); // [0, 0]
move(); // [0, 0]
```
换一种指定默认值的方法会有不同的结果
```js
function move({x, y} = { x: 0, y: 0 }) {
  return [x, y];
}
move({x: 3, y: 8}); // [3, 8]
move({x: 3}); // [3, undefined]
move({}); // [undefined, undefined]
move(); // [0, 0]
```