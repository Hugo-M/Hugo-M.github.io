---
title: 函数柯里化
date: 2018-03-14 22:00:45
tags: JavaScript
---
函数式编程在把函数当作一等公民的同时，就不可避免的会产生“柯里化”这种用法。
函数柯里化是逐步传参，逐步缩小函数的适用范围，逐步求解的过程。
```
// 通用的柯里化函数, 实现把所有参数传递给fn
var currying = function (fn) {
    var _args = [];
    return function () {
        if (arguments.length === 0) {
            return fn.apply(this, _args);
        }
        Array.prototype.push.apply(_args, [].slice.call(arguments));
        return arguments.callee;
    }
};
```
<!-- more -->
### 推迟计算
柯里化可以推迟计算，需要的时候再去求值。比如一家店要计算每月的盈利，首先要记录每天的盈利，这个就可以使用柯里化函数去解决。
```
var multi = function() {
  var total = 0;
  var len = arguments.length
  for (var i = 0; i < len; i++) {
      total += arguments[i];
  };
  return total;
};

var sum = currying(multi);

sum(100, 200)(300);
sum(400);
console.log(sum()); // 1000
console.log(sum(3)(30)(300)()); // 1333
```

### 复用参数
柯里化还可以复用参数。比如五千元买入不同的股票，计算三个月后各自的总价值。在实现参数复用之前需要改造一下之前通用的柯里化函数。
```
function currying2(fn) {
  var slice = Array.prototype.slice,
  __args = slice.call(arguments, 1); // 这里的arguments是currying2的参数, 可复用
  return function () {
    var __inargs = slice.call(arguments); // 这里的arguments是匿名函数的参数
    return fn.apply(null, __args.concat(__inargs));
  };
}
```
```
var sum2 = currying2(multi, 5000); // 复用了初始投资这个参数
console.log(sum2(45, 33, 90)); // 5168
console.log(sum2(13, 40, 120); // 5173
```
### 避免多次判断
```
var addEvent = function(el, type, fn, capture) {
    if (window.addEventListener) {
        el.addEventListener(type, function(e) {
            fn.call(el, e);
        }, capture);
    } else if (window.attachEvent) {
        el.attachEvent("on" + type, function(e) {
            fn.call(el, e);
        });
    } 
};
```
以上代码，我们每次使用`addEvent`为元素添加事件的时候，`IE6/IE7`都会走一遍`if...else if...`，其实使用柯里化只要一次判定就可以了，如下。
```
var addEvent = (function(){
  if (window.addEventListener) {
    return function(el, sType, fn, capture) {
      el.addEventListener(sType, function(e) {
        fn.call(el, e);
      }, (capture));
    };
  } else if (window.attachEvent) {
    return function(el, sType, fn, capture) {
      el.attachEvent("on" + sType, function(e) {
        fn.call(el, e);
      });
    };
  }
})();
```
