---
title: 函数柯里化
date: 2018-03-14 22:00:45
tags: JavaScript
---

函数式编程在把函数当作一等公民的同时，就不可避免的会产生“柯里化”这种用法。
函数柯里化是逐步传参，逐步缩小函数的适用范围，逐步求解的过程。

```js
// 通用的柯里化函数, 实现把所有参数传递给 fn
var currying = function(fn) {
  var _args = [];
  return function() {
    // 当没有参数时，传入累积的参数执行 fn
    if (arguments.length === 0) return fn.apply(this, _args);
    // 当有参数时，进行参数的收集，并返回函数自身
    [].push.apply(_args, [].slice.call(arguments));
    return arguments.callee;
  };
};
```

<!-- more -->

### 推迟计算

柯里化可以推迟计算，需要的时候再去求值。比如一家店要计算每月的盈利，首先要记录每天的盈利，这个就可以使用柯里化函数去解决。

```js
var multi = function() {
  var total = 0;
  var len = arguments.length;
  for (var i = 0; i < len; i++) {
    total += arguments[i];
  }
  return total;
};

var sum = currying(multi);

sum(100, 200)(300);
sum(400);
console.log(sum()); // 1000
console.log(sum(3)(30)(300)()); // 1333
```

### 复用参数

柯里化还可以复用参数。比如五千元买入不同的股票，计算三个月后各自的总价值。实现参数复用只需要将  curring 函数修改一行代码。

```js
var currying2 = function(fn) {
  var _args = [].slice.call(arguments, 1); // 修改了此行
  return function() {
    if (arguments.length === 0) return fn.apply(this, _args);
    [].push.apply(_args, [].slice.call(arguments));
    return arguments.callee;
  };
};
```

```js
var sum2 = currying2(multi, 5000); // 复用了初始投资这个参数
console.log(sum2(45, 33, 90)()); // 5168
console.log(sum2(13, 40, 120)()); // 5173
```

### 提前返回

```js
var addEvent = function(el, type, fn, capture) {
  if (window.addEventListener) {
    el.addEventListener(
      type,
      function(e) {
        fn.call(el, e);
      },
      capture
    );
  } else if (window.attachEvent) {
    el.attachEvent("on" + type, function(e) {
      fn.call(el, e);
    });
  }
};
```

以上代码，我们每次使用`addEvent`为元素添加事件的时候，`IE6/IE7`都会走一遍`if...else if...`，其实使用柯里化只要一次判定就可以了，如下。

```js
var addEvent = (function() {
  if (window.addEventListener) {
    return function(el, sType, fn, capture) {
      el.addEventListener(
        sType,
        function(e) {
          fn.call(el, e);
        },
        capture
      );
    };
  } else if (window.attachEvent) {
    return function(el, sType, fn, capture) {
      el.attachEvent("on" + sType, function(e) {
        fn.call(el, e);
      });
    };
  }
})();
```
