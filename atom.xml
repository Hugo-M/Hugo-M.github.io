<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hank&#39;s Blog</title>
  
  <subtitle>The brain is a good thing if you often use it.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hangermeng.top/"/>
  <updated>2021-01-19T06:42:29.031Z</updated>
  <id>https://hangermeng.top/</id>
  
  <author>
    <name>Hank</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vue中computed的实现</title>
    <link href="https://hangermeng.top/2020/10/05/vue%E4%B8%ADcomputed%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://hangermeng.top/2020/10/05/vue中computed的实现/</id>
    <published>2020-10-05T12:18:28.000Z</published>
    <updated>2021-01-19T06:42:29.031Z</updated>
    
    <content type="html"><![CDATA[<p>vue 中的 computed 属性的值只有当内部依赖的 data 属性变化时才会重新求值，这是怎么做到的呢。假设传入以下 computed ：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  ab: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以下是 vue 初始化的操作：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initState</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  vm._watchers = []</span><br><span class="line">  <span class="keyword">const</span> opts = vm.$options</span><br><span class="line">  <span class="keyword">if</span> (opts.props) initProps(vm, opts.props)</span><br><span class="line">  <span class="keyword">if</span> (opts.methods) initMethods(vm, opts.methods)</span><br><span class="line">  <span class="keyword">if</span> (opts.data) &#123;</span><br><span class="line">    initData(vm)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    observe(vm._data = &#123;&#125;, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (opts.computed) initComputed(vm, opts.computed)</span><br><span class="line">  <span class="keyword">if</span> (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;</span><br><span class="line">    initWatch(vm, opts.watch)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>initComputed 做到的事情是实例化 Watcher 以及将属性挂载到实例上：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initComputed</span> (<span class="params">vm: Component, computed: Object</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//声明一个watchers，同时挂载到Vue实例上</span></span><br><span class="line">  <span class="keyword">const</span> watchers = vm._computedWatchers = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  <span class="comment">//是否是服务器渲染</span></span><br><span class="line">  <span class="keyword">const</span> isSSR = isServerRendering()</span><br><span class="line"></span><br><span class="line">  <span class="comment">//遍历传入的computed</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> computed) &#123;</span><br><span class="line">    <span class="comment">//userDef是computed对象中的每一个方法</span></span><br><span class="line">    <span class="keyword">const</span> userDef = computed[key]</span><br><span class="line">    <span class="keyword">const</span> getter = <span class="keyword">typeof</span> userDef === <span class="string">'function'</span> ? userDef : userDef.get</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; getter == <span class="literal">null</span>) &#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">`Getter is missing for computed property "<span class="subst">$&#123;key&#125;</span>".`</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果不是服务端渲染的，就创建一个Watcher实例</span></span><br><span class="line">    <span class="keyword">if</span> (!isSSR) &#123;</span><br><span class="line">      <span class="comment">// 关键代码，之后会提到</span></span><br><span class="line">      watchers[key] = <span class="keyword">new</span> Watcher( </span><br><span class="line">        vm,</span><br><span class="line">        getter || noop,</span><br><span class="line">        noop,</span><br><span class="line">        &#123; <span class="attr">lazy</span>: <span class="literal">true</span> &#125; <span class="comment">// 关键参数</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</span><br><span class="line">      <span class="comment">//如果computed中的key没有在vm中，通过defineComputed挂载上去</span></span><br><span class="line">      defineComputed(vm, key, userDef) <span class="comment">// 关键代码，之后会提到</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="comment">//后面都是警告computed中的key重名的</span></span><br><span class="line">      <span class="keyword">if</span> (key <span class="keyword">in</span> vm.$data) &#123;</span><br><span class="line">        warn(<span class="string">`The computed property "<span class="subst">$&#123;key&#125;</span>" is already defined in data.`</span>, vm)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vm.$options.props &amp;&amp; key <span class="keyword">in</span> vm.$options.props) &#123;</span><br><span class="line">        warn(<span class="string">`The computed property "<span class="subst">$&#123;key&#125;</span>" is already defined as a prop.`</span>, vm)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到 Watcher 构造器接受了一个参数 <code>{ lazy: true }</code>，下边进入 Watcher 介绍该参数起的作用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下为关键代码</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (</span><br><span class="line">    vm: Component,</span><br><span class="line">    expOrFn: string | Function,</span><br><span class="line">    cb: Function,</span><br><span class="line">    options?: ?Object,</span><br><span class="line">    isRenderWatcher?: boolean</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">this</span>.vm = vm</span><br><span class="line">    vm._watchers.push(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">if</span> (options) &#123;</span><br><span class="line">      <span class="keyword">this</span>.deep = !!options.deep</span><br><span class="line">      <span class="keyword">this</span>.user = !!options.user</span><br><span class="line">      <span class="keyword">this</span>.lazy = !!options.lazy</span><br><span class="line">      <span class="keyword">this</span>.sync = !!options.sync</span><br><span class="line">      <span class="number">1</span>efore = options.before</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.deep = <span class="keyword">this</span>.user = <span class="keyword">this</span>.lazy = <span class="keyword">this</span>.sync = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.dirty = <span class="keyword">this</span>.lazy <span class="comment">// for lazy watchers</span></span><br><span class="line">    <span class="comment">// 此处省略代码...</span></span><br><span class="line">    <span class="comment">// 当 lazy 为 true 时，不计算值，返回 undefined</span></span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.lazy ? <span class="literal">undefined</span> : <span class="keyword">this</span>.get()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时开头假设的<code>this.ab</code>的值为<code>undefined</code>，这里可以看到<strong>计算属性在初始化的时候不计算其值</strong>。然后代码执行到<code>defineComputed(vm, key, userDef)</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下为关键代码</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineComputed</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  target: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  userDef: Object | Function</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 不是服务端渲染就使用环境</span></span><br><span class="line">  <span class="keyword">const</span> shouldCache = !isServerRendering()</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> userDef === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理 userDef 为函数的情况</span></span><br><span class="line">    sharedPropertyDefinition.get = shouldCache</span><br><span class="line">    ? createComputedGetter(key)</span><br><span class="line">    : createGetterInvoker(userDef)</span><br><span class="line">    sharedPropertyDefinition.set = noop</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 处理 userDef 为对象的情况</span></span><br><span class="line">    sharedPropertyDefinition.get = userDef.get</span><br><span class="line">    ? shouldCache &amp;&amp; userDef.cache !== <span class="literal">false</span></span><br><span class="line">      ? createComputedGetter(key)</span><br><span class="line">      : createGetterInvoker(userDef.get)</span><br><span class="line">    : noop</span><br><span class="line">    sharedPropertyDefinition.set = userDef.set || noop</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, key, sharedPropertyDefinition)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在<code>createComputedGetter</code>中用到了<code>watcher.dirty</code>，而其初始值由前面传入的参数<code>{ lazy: true }</code>决定。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComputedGetter</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">computedGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> watcher = <span class="keyword">this</span>._computedWatchers &amp;&amp; <span class="keyword">this</span>._computedWatchers[key]</span><br><span class="line">    <span class="keyword">if</span> (watcher) &#123;</span><br><span class="line">      <span class="comment">// watcher.dirty 为 true ，调用 watcher.evaluate()</span></span><br><span class="line">      <span class="keyword">if</span> (watcher.dirty) &#123;</span><br><span class="line">        watcher.evaluate()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        <span class="comment">// 依赖收集，很关键，保证依赖变更时重新求值</span></span><br><span class="line">        watcher.depend()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> watcher.value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后执行<code>Object.defineProperty(target, key, sharedPropertyDefinition)</code>，代码执行到这里其实是把计算属性的 setter 和 getter 创建好了。所以，<strong>计算属性如果未被消费不会计算值</strong>，其值始终是 <code>undefined</code>。</p><p>当计算属性被用到时（例如在 render 或 methods 中），此时会触发<code>computedGetter</code>，进而执行<code>evaluate</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">evaluate</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.value = <span class="keyword">this</span>.get()</span><br><span class="line">  <span class="keyword">this</span>.dirty = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用<code>this.get()</code>会进行依赖收集，最后返回计算属性的值，此时终于获取到了计算属性的值。这里为什么要将<code>this.dirty</code>设为<code>false</code>呢，是为了实现计算属性基于它的依赖进行缓存的，也就依赖没变时，不重新计算，而是使用缓存。<br>回顾以下代码，在第一次获取值后，<code>watcher.lazy</code>始终为<code>false</code>，也就永远不会执行<code>watcher.evaluate()</code>，所以这个计算属性永远不会重新求值，一直使用上一次获得的值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (watcher.dirty) &#123;</span><br><span class="line">  watcher.evaluate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那什么时候会重新求值呢，当<code>watcher.dirty</code>为<code>true</code>时，怎么改变这个值呢，当依赖变更的时候，即在<code>watcher.update()</code>中：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">update () &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.lazy) &#123;</span><br><span class="line">    <span class="keyword">this</span>.dirty = <span class="literal">true</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sync) &#123;</span><br><span class="line">    <span class="keyword">this</span>.run()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    queueWatcher(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以开头的假设为例，当<code>this.a</code>改变时，将触发<code>dep.notify()</code>，然后执行该<code>dep</code>中所有 <code>watcher</code>的<code>update</code>方法，其中就包括<code>this.ab</code>的<code>watcher.update()</code>（这个<code>watcher</code>是在前面的<code>watcher.depend()</code>中添加的），此时<code>watcher.dirty</code>会被改变为<code>true</code>，因此当再次取<code>this.ab</code>的值时，会重新计算。</p><h3 id="计算属性的依赖变更如何触发渲染"><a href="#计算属性的依赖变更如何触发渲染" class="headerlink" title="计算属性的依赖变更如何触发渲染"></a>计算属性的依赖变更如何触发渲染</h3><p>如果计算属性在模板或 render 函数中被使用，在触发<code>计算watcher.update()</code>后，会触发<code>渲染watcher.update()</code>，此时取<code>this.ab</code>，会得到重新计算后的值。<br>但怎么保证<code>渲染watcher.update()</code>在<code>计算watcher.update()</code>后执行呢，因为如果在之前执行得到的<code>this.ab</code>会是旧值（因为此时<code>watcher.dirty</code>还为<code>false</code>）。这涉及到全局的 <code>Dep.target</code> 状态是用一个栈 <code>targetStack</code> 来保存。</p><p>假设在 render 函数中使用了<code>this.ab</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">render () &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.ab&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当执行 render 函数时，此时<code>Dep.target</code>指向<code>渲染watcher</code>，<code>targetStack = [渲染watcher]</code>，执行<code>this.a + 1</code>，读取到了<code>this.a</code>，触发<code>a</code>的<code>get</code>方法，此时<code>Dep.target</code>指向<code>计算watcher</code>，<code>targetStack = [渲染watcher，计算watcher]</code>，调用<code>dep.depend()</code>收集<code>计算watcher</code>作为依赖，<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dep.depend()</span></span><br><span class="line">depend () &#123;</span><br><span class="line">  <span class="keyword">if</span> (Dep.target) &#123; <span class="comment">// 此时`Dep.target`指向`计算watcher`</span></span><br><span class="line">    Dep.target.addDep(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>经历了这样的一个收集的流程后，此时的一些状态：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ab 的计算watcher</span></span><br><span class="line">&#123;</span><br><span class="line">  deps: [ a的dep ],</span><br><span class="line">  dirty: <span class="literal">false</span>, <span class="comment">// 求值完了 所以是false</span></span><br><span class="line">  value: <span class="number">2</span>,</span><br><span class="line">  getter: ƒ ab(),</span><br><span class="line">  lazy: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a的dep</span></span><br><span class="line">&#123;</span><br><span class="line">  subs: [ ab的计算watcher ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时求值结束，回到<code>计算watcher</code>的<code>get</code>方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// watcher.get</span></span><br><span class="line"><span class="keyword">get</span> () &#123;</span><br><span class="line">  pushTarget(<span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">let</span> value</span><br><span class="line">  <span class="keyword">const</span> vm = <span class="keyword">this</span>.vm</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    value = <span class="keyword">this</span>.getter.call(vm, vm)</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// `计算watcher`出栈，此时`Dep.target`指向`渲染watcher`，`targetStack = [渲染watcher]`。</span></span><br><span class="line">    popTarget()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>进入<code>this.ab</code>的<code>getter</code>函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(vm, <span class="string">'ab'</span>, &#123; </span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (watcher.dirty) &#123;</span><br><span class="line">      watcher.evaluate()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Dep.target) &#123; <span class="comment">// 此时`Dep.target`指向`渲染watcher`</span></span><br><span class="line">      watcher.depend()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> watcher.value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// watcher.depend</span></span><br><span class="line">depend () &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="keyword">this</span>.deps.length</span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="keyword">this</span>.deps[i].depend()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 <code>ab 的计算watcher</code> 的 deps 里保存了 <code>a</code> 的 dep，因此又会调用 <code>a</code> 的 <code>dep.depend()</code>，会把<code>渲染watcher</code> 存放进自身的 subs 中，最后<code>a</code>的 dep 如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  subs: [ ab的计算watcher，渲染watcher ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一切初始化已经完成，若改变<code>a</code>的值，将触发 <code>a</code> 的 <code>dep.notify</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">notify () &#123;</span><br><span class="line">  <span class="keyword">const</span> subs = <span class="keyword">this</span>.subs.slice()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">    subs[i].update()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上代码依次调用了<code>计算watcher.update()</code>和<code>渲染watcher.update()</code>，保证<code>渲染watcher.update()</code>在<code>计算watcher.update()</code>后执行，此时 render 函数中能获取到最新的计算属性的值。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>通过改变<code>this.dirty</code>的值来实现缓存，当<code>this.dirty === true</code>时，再次访问才会执行<code>watcher.evaluate()</code>获得新值。</li><li>计算属性的依赖变更时触发<code>计算watcher.update()</code>，执行<code>this.dirty = true</code>，使得再次获取计算属性值时被重新计算。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;vue 中的 computed 属性的值只有当内部依赖的 data 属性变化时才会重新求值，这是怎么做到的呢。假设传入以下 computed ：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;computed: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ab: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.a + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;以下是 vue 初始化的操作：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;initState&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;vm: Component&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  vm._watchers = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; opts = vm.$options&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (opts.props) initProps(vm, opts.props)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (opts.methods) initMethods(vm, opts.methods)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (opts.data) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    initData(vm)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    observe(vm._data = &amp;#123;&amp;#125;, &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;/* asRootData */&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (opts.computed) initComputed(vm, opts.computed)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (opts.watch &amp;amp;&amp;amp; opts.watch !== nativeWatch) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    initWatch(vm, opts.watch)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Vue.js" scheme="https://hangermeng.top/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>js变量提升</title>
    <link href="https://hangermeng.top/2020/09/02/js%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/"/>
    <id>https://hangermeng.top/2020/09/02/js变量提升/</id>
    <published>2020-09-02T07:08:04.000Z</published>
    <updated>2021-01-19T06:42:29.026Z</updated>
    
    <content type="html"><![CDATA[<h3 id="全局中的解析和执行过程"><a href="#全局中的解析和执行过程" class="headerlink" title="全局中的解析和执行过程"></a>全局中的解析和执行过程</h3><p>预处理：创建一个词法环境（LexicalEnvironment，在后面简写为LE），扫描JS中的<strong>用声明的方式声明的函数</strong>和<strong>用var定义的变量</strong>，将它们加到预处理阶段的词法环境中去。</p><h4 id="一、全局环境中如何理解预处理"><a href="#一、全局环境中如何理解预处理" class="headerlink" title="一、全局环境中如何理解预处理"></a>一、全局环境中如何理解预处理</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;<span class="comment">//用var定义的变量，以赋值</span></span><br><span class="line"><span class="keyword">var</span> b;<span class="comment">//用var定义的变量，未赋值</span></span><br><span class="line">c = <span class="number">3</span>;<span class="comment">//未定义，直接赋值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params"></span>)</span>&#123;<span class="comment">//用声明的方式声明的函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> e = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//函数表达式</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'world'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在预处理时上面代码创建词法作用域可以这样表示：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LE &#123; <span class="comment">// 此时的LE相当于window</span></span><br><span class="line">    a:<span class="literal">undefined</span></span><br><span class="line">    b:<span class="literal">undefined</span></span><br><span class="line">    d:对函数的一个引用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h4 id="二、命名冲突的处理"><a href="#二、命名冲突的处理" class="headerlink" title="二、命名冲突的处理"></a>二、命名冲突的处理</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(f);</span><br><span class="line"><span class="keyword">var</span> f = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'foodoir'</span>);&#125;</span><br><span class="line"><span class="comment">// 输出 function f()&#123;console.log('foodoir');&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(f);</span><br><span class="line"><span class="keyword">var</span> f = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'foodoir'</span>);&#125;</span><br><span class="line"><span class="comment">// 输出 function f()&#123;console.log('foodoir');&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(f);</span><br><span class="line"><span class="keyword">var</span> f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> f = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 输出 undefined</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(f);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'foodoir'</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'hello world'</span>);&#125;</span><br><span class="line"><span class="comment">// 输出 function f()&#123;console.log('hello world');&#125;</span></span><br></pre></td></tr></table></figure><p>原因：<strong>处理函数声明有冲突时，会覆盖；处理变量声明有冲突时，会忽略</strong>。在既有函数声明又有变量声明的时候，函数声明的权重总是高一些，所以最终结果往往是指向函数声明的引用。</p><h3 id="函数中的解析和执行过程"><a href="#函数中的解析和执行过程" class="headerlink" title="函数中的解析和执行过程"></a>函数中的解析和执行过程</h3><p>函数中的解析和执行过程的区别不是很大，但是函数中有个arguments我们需要注意一下，我们来看下面的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure></p><p>分析函数的预处理，它和全局的预处理类似，它的词法结构如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LE &#123;</span><br><span class="line">    b: <span class="number">2</span></span><br><span class="line">    a: 指向函数的引用</span><br><span class="line">    <span class="built_in">arguments</span>：<span class="number">2</span> <span class="comment">// 调用函数时实际调用的参数个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出的结果为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>当传入的参数值有一个时：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p><p>这个时候的词法结构如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LE &#123;</span><br><span class="line">    b: <span class="literal">undefined</span></span><br><span class="line">    a: 指向函数的引用</span><br><span class="line">    <span class="built_in">arguments</span>：<span class="number">2</span> <span class="comment">// 调用函数时实际调用的参数个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="关于JS作用域和作用域链"><a href="#关于JS作用域和作用域链" class="headerlink" title="关于JS作用域和作用域链"></a>关于JS作用域和作用域链</h3><p>在编程语言中，作用域一般可以分为四类：块级作用域、函数作用域、动态作用域、词法作用域（也称静态作用域）</p><h4 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h4><p>在其它C类语言中，用大括号括起来的部分被称为作用域，但是在javascript并没有块级作用域，来看下面一个例子：~<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br></pre></td></tr></table></figure></p><p>它的结果为3，原因：执行完for循环后，此时的i的值为3，由于javascript并没有块级作用域，在后面仍有效。</p><h4 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h4><p>没有纯粹的函数的作用域</p><h4 id="动态作用域"><a href="#动态作用域" class="headerlink" title="动态作用域"></a>动态作用域</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">    f();</span><br><span class="line">&#125;</span><br><span class="line">f1();</span><br></pre></td></tr></table></figure><p>如果说存在动态作用域，那么结果应该是分别为1，但是最终结果是：x is not defined。所以javascript也没有动态作用域</p><h4 id="词法作用域（也称静态作用域）"><a href="#词法作用域（也称静态作用域）" class="headerlink" title="词法作用域（也称静态作用域）"></a>词法作用域（也称静态作用域）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">100</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">    f();</span><br><span class="line">&#125;</span><br><span class="line">f1();</span><br></pre></td></tr></table></figure><p>弹出100。说明javascript的作用域为静态作用域 ，分析：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// f [[scope]]  == LE ==  window</span></span><br><span class="line"><span class="comment">//创建一个作用域对象f [[scope]]，它等于创建它时候的词法环境LE（据前面的知识我们又可以知道此时的词法环境等于window）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">    f();<span class="comment">//真正执行的时候（一步一步往上找）LE  -&gt;f.[[scope]]  ==  window</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在词法解析阶段，就已经确定了相关的作用域。作用域还会形成一个相关的链条，我们称之为作用域链。来看下面的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;    <span class="comment">// f.scope == window</span></span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">100</span>;<span class="comment">//f.LE == &#123;x:100,g:函数&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> g = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">// g.scope = f.LE        </span></span><br><span class="line">        alert(x);</span><br><span class="line">    &#125;</span><br><span class="line">    g();<span class="comment">//在执行g的时候，先找 g.scope，没有的话再找 f.LE，还没有的话找f.scope……一直往上找window    </span></span><br><span class="line">&#125;</span><br><span class="line">f();</span><br></pre></td></tr></table></figure></p><p>new Function的情况又不一样，<strong>Function 创建的函数只能在全局作用域中运行</strong>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x= <span class="number">123</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//g.[[scope]]  == window</span></span><br><span class="line">    <span class="keyword">var</span> g = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">""</span>,<span class="string">"alert(x)"</span>);</span><br><span class="line">    g();</span><br><span class="line">&#125;</span><br><span class="line">f(); <span class="comment">//结果为：123</span></span><br></pre></td></tr></table></figure></p><p><a href="https://www.cnblogs.com/libin-1/p/5979303.html" target="_blank" rel="noopener">原文地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;全局中的解析和执行过程&quot;&gt;&lt;a href=&quot;#全局中的解析和执行过程&quot; class=&quot;headerlink&quot; title=&quot;全局中的解析和执行过程&quot;&gt;&lt;/a&gt;全局中的解析和执行过程&lt;/h3&gt;&lt;p&gt;预处理：创建一个词法环境（LexicalEnvironment，在后面简写为LE），扫描JS中的&lt;strong&gt;用声明的方式声明的函数&lt;/strong&gt;和&lt;strong&gt;用var定义的变量&lt;/strong&gt;，将它们加到预处理阶段的词法环境中去。&lt;/p&gt;
&lt;h4 id=&quot;一、全局环境中如何理解预处理&quot;&gt;&lt;a href=&quot;#一、全局环境中如何理解预处理&quot; class=&quot;headerlink&quot; title=&quot;一、全局环境中如何理解预处理&quot;&gt;&lt;/a&gt;一、全局环境中如何理解预处理&lt;/h4&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//用var定义的变量，以赋值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; b;&lt;span class=&quot;comment&quot;&gt;//用var定义的变量，未赋值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;c = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//未定义，直接赋值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;d&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;span class=&quot;comment&quot;&gt;//用声明的方式声明的函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;hello&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; e = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;span class=&quot;comment&quot;&gt;//函数表达式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;world&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在预处理时上面代码创建词法作用域可以这样表示：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;LE &amp;#123; &lt;span class=&quot;comment&quot;&gt;// 此时的LE相当于window&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    a:&lt;span class=&quot;literal&quot;&gt;undefined&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    b:&lt;span class=&quot;literal&quot;&gt;undefined&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    d:对函数的一个引用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://hangermeng.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>this指向</title>
    <link href="https://hangermeng.top/2020/09/02/this%E6%8C%87%E5%90%91/"/>
    <id>https://hangermeng.top/2020/09/02/this指向/</id>
    <published>2020-09-02T04:44:56.000Z</published>
    <updated>2021-01-19T06:42:29.030Z</updated>
    
    <content type="html"><![CDATA[<p>关于 this 指向，部分情况要区分严格模式和非严格模式（正常模式）：</p><ul><li>作为普通函数调用：严格模式下，this的值是 undefined，非严格模式下，this指向全局对象。</li><li>作为方法调用：this指向所属对象。</li><li>作为构造函数调用：this指向实例化的对象。</li><li>通过call, apply, bind调用：如果指定了第一个参数thisArg，this的值就是thisArg的值（如果是原始值，会包装为对象）；如果不传thisArg，要判断严格模式，严格模式下this是undefined，非严格模式下this指向全局对象。</li></ul><a id="more"></a><blockquote><p>严格模式通过在脚本或函数的头部添加 <code>&quot;use strict&quot;;</code> 表达式来声明。<a href="https://segmentfault.com/a/1190000015798019" target="_blank" rel="noopener">严格模式和非严格模式的区别</a></p></blockquote><h3 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    num: <span class="number">2</span>,</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = <span class="number">3</span>;</span><br><span class="line">        <span class="comment">// 这里的立即指向函数，因为我们没有手动去指定它的this指向，所以都会指向window</span></span><br><span class="line">        (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 所有这个 this.num 就等于 window.num</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.num); <span class="comment">// **严格模式下此行报错**</span></span><br><span class="line">            <span class="keyword">this</span>.num = <span class="number">4</span>;</span><br><span class="line">        &#125;)();</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.num);</span><br><span class="line">    &#125;,</span><br><span class="line">    sub: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.num) <span class="comment">// **严格模式下此行报错**</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在通过obj.add 调用add 函数时，函数的this指向的是obj,这时候第一个this.num=3</span></span><br><span class="line"><span class="comment"> * 相当于 obj.num = 3 但是里面的立即指向函数this依然是window,</span></span><br><span class="line"><span class="comment"> * 所以 立即执行函数里面console.log(this.num)输出1，同时 window.num = 4</span></span><br><span class="line"><span class="comment"> * 立即执行函数之后，再输出`this.num`,这时候`this`是`obj`,所以输出3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">obj.add() <span class="comment">// 输出 1 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过上面`obj.add`的执行，obj.name 已经变成了3</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.num) <span class="comment">// 输出3</span></span><br><span class="line"><span class="built_in">console</span>.log(num) <span class="comment">// 输出4</span></span><br><span class="line"><span class="comment">// 如果将obj.sub 赋值给一个新的变量，那么这个函数的作用域将会变成新变量的作用域</span></span><br><span class="line"><span class="keyword">const</span> sub = obj.sub</span><br><span class="line"><span class="comment">// 作用域变成了window </span></span><br><span class="line">sub() <span class="comment">// 输出4</span></span><br></pre></td></tr></table></figure><p>非严格模式下输出：<code>1</code>、<code>3</code>、<code>3</code>、<code>4</code>、<code>4</code></p><p>严模式下报错：<code>Cannot read property &#39;num&#39; of undefined</code></p><h3 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">num</span>: <span class="number">20</span>&#125;</span><br><span class="line">obj.fn = (<span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.num = num * <span class="number">3</span></span><br><span class="line">  num++ <span class="comment">// **严格模式下此行报错**</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.num += n</span><br><span class="line">    num++</span><br><span class="line">    <span class="built_in">console</span>.log(num)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(obj.num)</span><br><span class="line"><span class="keyword">var</span> fn = obj.fn</span><br><span class="line">fn(<span class="number">5</span>)</span><br><span class="line">obj.fn(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">console</span>.log(num, obj.num) <span class="comment">// **严格模式下此行报错**</span></span><br></pre></td></tr></table></figure><p>非严格模式下输出：<code>22</code>、<code>23</code>、<code>65</code>、<code>30</code></p><p>严模式下报错：<code>Cannot set property &#39;num&#39; of undefined</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于 this 指向，部分情况要区分严格模式和非严格模式（正常模式）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作为普通函数调用：严格模式下，this的值是 undefined，非严格模式下，this指向全局对象。&lt;/li&gt;
&lt;li&gt;作为方法调用：this指向所属对象。&lt;/li&gt;
&lt;li&gt;作为构造函数调用：this指向实例化的对象。&lt;/li&gt;
&lt;li&gt;通过call, apply, bind调用：如果指定了第一个参数thisArg，this的值就是thisArg的值（如果是原始值，会包装为对象）；如果不传thisArg，要判断严格模式，严格模式下this是undefined，非严格模式下this指向全局对象。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://hangermeng.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>《原则》-生活原则</title>
    <link href="https://hangermeng.top/2019/07/07/%E3%80%8A%E5%8E%9F%E5%88%99%E3%80%8B-%E7%94%9F%E6%B4%BB%E5%8E%9F%E5%88%99/"/>
    <id>https://hangermeng.top/2019/07/07/《原则》-生活原则/</id>
    <published>2019-07-07T08:18:09.000Z</published>
    <updated>2021-01-19T06:42:29.032Z</updated>
    
    <content type="html"><![CDATA[<p>你想要什么，事实是什么，如何实现愿望。考察影响你的那些事物的规律，理解背后的因果关系，并利用之。</p><ul><li>做到头脑极度开放</li><li>你的未来取决于你的视角</li><li>没有痛苦就没有收获，痛苦 + 反思 = 进步</li><li>五步实现愿望：明确目标、找出并不容忍问题、找打问题的根源、规划方案、坚定地执行</li><li>如果你找到了解决方案，弱点是不重要的</li><li>只有设身处地，才能合理评估另一种观点的价值</li><li>寻找最好的答案，而不是你自己能得出的最好答案</li><li>为最坏的情况做准备</li><li>影响好决策的最大威胁是有害的情绪</li><li>不必过于精确，明白关键性的 20% </li><li>提高押对的概率始终有价值</li><li>先把“必做之事”做完，在做“想做之事”</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;你想要什么，事实是什么，如何实现愿望。考察影响你的那些事物的规律，理解背后的因果关系，并利用之。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;做到头脑极度开放&lt;/li&gt;
&lt;li&gt;你的未来取决于你的视角&lt;/li&gt;
&lt;li&gt;没有痛苦就没有收获，痛苦 + 反思 = 进步&lt;/li&gt;
&lt;li&gt;五步实现
      
    
    </summary>
    
    
      <category term="books" scheme="https://hangermeng.top/tags/books/"/>
    
  </entry>
  
  <entry>
    <title>瘫坐</title>
    <link href="https://hangermeng.top/2019/04/24/%E7%98%AB%E5%9D%90/"/>
    <id>https://hangermeng.top/2019/04/24/瘫坐/</id>
    <published>2019-04-24T02:27:14.000Z</published>
    <updated>2021-01-19T06:42:29.041Z</updated>
    
    <content type="html"><![CDATA[<p>黑暗伴随零星灯光延伸到无限远处<br>伴着疲惫瘫坐<br>什么都不想做<br>就这样凝望时光的剪影<br>如若可以<br>宁静的<br>安详的入睡<br>夜色暗<br>夏风飘</p><a id="more"></a><p>岁月如烟<br>容颜褪色<br>在坚实的大地之上<br>是否可以再次获得<br>激情的漩涡</p><p>一路春花落<br>不忍回头<br>都是美梦与过错</p><blockquote><p><em>语寺</em><br><em>2014.5.24</em></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;黑暗伴随零星灯光延伸到无限远处&lt;br&gt;伴着疲惫瘫坐&lt;br&gt;什么都不想做&lt;br&gt;就这样凝望时光的剪影&lt;br&gt;如若可以&lt;br&gt;宁静的&lt;br&gt;安详的入睡&lt;br&gt;夜色暗&lt;br&gt;夏风飘&lt;/p&gt;
    
    </summary>
    
    
      <category term="writing" scheme="https://hangermeng.top/tags/writing/"/>
    
  </entry>
  
  <entry>
    <title>常用git命令</title>
    <link href="https://hangermeng.top/2019/04/15/%E5%B8%B8%E7%94%A8git%E5%91%BD%E4%BB%A4/"/>
    <id>https://hangermeng.top/2019/04/15/常用git命令/</id>
    <published>2019-04-15T01:27:23.000Z</published>
    <updated>2021-01-19T06:42:29.039Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>git reset [commit]</td><td>重置当前分支的指针为指定 commit，同时重置暂存区，但工作区不变</td></tr><tr><td>git reset –hard</td><td>重置暂存区与工作区，与上一次 commit 保持一致</td></tr><tr><td>git add [file1] … (git add [dir]）</td><td>添加指定文件(目录)到暂存区</td></tr><tr><td>git rm [file1] …</td><td>删除工作区文件，并且将这次删除放入暂存区</td></tr><tr><td>git commit -m [message]</td><td>提交暂存区到仓库区</td></tr><tr><td>git branch</td><td>列出所有本地分支</td></tr><tr><td>git branch -r</td><td>列出所有远程分支</td></tr><tr><td>git branch -a</td><td>列出所有本地分支和远程分支</td></tr><tr><td>git branch [branch-name]</td><td>新建一个分支，但依然停留在当前分支</td></tr><tr><td>git branch -d [branch-name]</td><td>删除分支</td></tr><tr><td>git checkout -b [branch]</td><td>新建一个分支，并切换到该分支</td></tr><tr><td>git push origin [local_branch]:[remote_branch]</td><td>将本地分支推送到远程</td></tr><tr><td>git checkout [branch-name]</td><td>切换到指定分支，并更新工作区</td></tr><tr><td>git checkout -</td><td>切换到上一个分支</td></tr><tr><td>git checkout [file]</td><td>恢复暂存区的指定文件到工作区</td></tr><tr><td>git merge [branch]</td><td>合并指定分支到当前分支</td></tr><tr><td>git tag [tag]</td><td>新建一个 tag 在当前 commit</td></tr><tr><td>git log(git reflog)</td><td>显示当前分支的(最近)版本历史</td></tr><tr><td>git diff HEAD</td><td>显示工作区与当前分支最新 commit 之间的差异</td></tr><tr><td>git push origin [branch]</td><td>上传本地指定分支到远程仓库</td></tr></tbody></table><blockquote><p><code>git checkout</code>可以缩写为<code>gco</code></p></blockquote><blockquote><p><code>HEAD</code> 指向当前分支，<code>HEAD^n</code>表示当前分支的第 n 个父提交，<code>HEAD~n</code>表示当前分支的第 n 个父提交，用于第一父母存在歧义的情况下</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;git reset [commit]&lt;/td&gt;
&lt;td&gt;重置当前分支的指针为指定 commit，同时重置暂存区，但工作区不变&lt;
      
    
    </summary>
    
    
      <category term="git" scheme="https://hangermeng.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Koa源码学习</title>
    <link href="https://hangermeng.top/2019/03/19/Koa%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>https://hangermeng.top/2019/03/19/Koa源码学习/</id>
    <published>2019-03-19T07:07:40.000Z</published>
    <updated>2021-01-19T06:42:29.016Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/koajs/koa" target="_blank" rel="noopener">Koa2 的源码</a> 相当的简短，因为抽离了路由、模板引擎等模块，只提供一个架子，而几乎所有的功能都需要由第三方中间件完成。阅读时建议对照源码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">. lib</span><br><span class="line">├── application.js  ---------- 构造 app 对象</span><br><span class="line">├── context.js  -------------- 构造 ctx 对象</span><br><span class="line">├── request.js --------------- 构造 req 对象</span><br><span class="line">└── response.js  ------------- 构造 res 对象</span><br></pre></td></tr></table></figure><p>底层原理同 express，即代理<code>http.createServer(requestHandler)</code>中的<code>requestHandler</code>，使用中间件来处理请求。</p><a id="more"></a><h3 id="代码梳理"><a href="#代码梳理" class="headerlink" title="代码梳理"></a>代码梳理</h3><p><code>application.js</code>中构造了 app 对象，初始化 context 属性 ，定义了 listen、use 等方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... 省略部分代码</span></span><br><span class="line"><span class="keyword">const</span> Emitter = <span class="built_in">require</span>(<span class="string">"events"</span>);</span><br><span class="line"><span class="keyword">const</span> onFinished = <span class="built_in">require</span>(<span class="string">"on-finished"</span>);</span><br><span class="line"><span class="keyword">const</span> response = <span class="built_in">require</span>(<span class="string">"./response"</span>);</span><br><span class="line"><span class="keyword">const</span> compose = <span class="built_in">require</span>(<span class="string">"koa-compose"</span>);</span><br><span class="line"><span class="keyword">const</span> context = <span class="built_in">require</span>(<span class="string">"./context"</span>);</span><br><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">"./request"</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span> <span class="keyword">extends</span> <span class="title">Emitter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.middleware = []; <span class="comment">// 存放中间件</span></span><br><span class="line">    <span class="keyword">this</span>.context = <span class="built_in">Object</span>.create(context);</span><br><span class="line">    <span class="keyword">this</span>.request = <span class="built_in">Object</span>.create(request);</span><br><span class="line">    <span class="keyword">this</span>.response = <span class="built_in">Object</span>.create(response);</span><br><span class="line">  &#125;</span><br><span class="line">  listen(...args) &#123;</span><br><span class="line">    <span class="keyword">const</span> server = http.createServer(<span class="keyword">this</span>.callback());</span><br><span class="line">    <span class="keyword">return</span> server.listen(...args);</span><br><span class="line">  &#125;</span><br><span class="line">  callback() &#123;</span><br><span class="line">    <span class="comment">// compose 函数把所有的中间件变成一个函数，后续介绍</span></span><br><span class="line">    <span class="keyword">const</span> fn = compose(<span class="keyword">this</span>.middleware);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 Emitter 中的 listenerCount 判断是否有error事件的监听器</span></span><br><span class="line">    <span class="comment">// 如果没有会为 error 事件注册默认的事件监听方法 onerror</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.listenerCount(<span class="string">"error"</span>)) <span class="keyword">this</span>.on(<span class="string">"error"</span>, <span class="keyword">this</span>.onerror);</span><br><span class="line">    <span class="keyword">const</span> handleRequest = <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 创建的 ctx 对象，并使 ctx.request = this.request, ctx.response = this.response</span></span><br><span class="line">      <span class="keyword">const</span> ctx = <span class="keyword">this</span>.createContext(req, res);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.handleRequest(ctx, fn);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> handleRequest;</span><br><span class="line">  &#125;</span><br><span class="line">  handleRequest(ctx, fnMiddleware) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = ctx.res;</span><br><span class="line">    res.statusCode = <span class="number">404</span>;</span><br><span class="line">    <span class="keyword">const</span> onerror = <span class="function"><span class="params">err</span> =&gt;</span> ctx.onerror(err);</span><br><span class="line">    <span class="comment">// respond 内读取ctx信息，把数据写入 res 中并响应请求</span></span><br><span class="line">    <span class="keyword">const</span> handleResponse = <span class="function"><span class="params">()</span> =&gt;</span> respond(ctx);</span><br><span class="line">    <span class="comment">// onFinished 确保一个流在关闭、完成和报错时都会执行注册的回调函数</span></span><br><span class="line">    onFinished(res, onerror);</span><br><span class="line">    <span class="comment">// fnMiddleware(ctx) 返回一个 Promise</span></span><br><span class="line">    <span class="keyword">return</span> fnMiddleware(ctx)</span><br><span class="line">      .then(handleResponse)</span><br><span class="line">      .catch(onerror);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h3><p><code>compose</code>接受一个包含中间件的数组作为参数，返回一个函数，且该函数会返回一个 Promise 。<code>compose</code>是 koa 洋葱模型的关键 ，来看一下 koa-compose 的源码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">middleware</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">context, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dispatch(<span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 如果一个中间件内多次调用 next，报错</span></span><br><span class="line">      <span class="keyword">if</span> (i &lt;= index)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"next() called multiple times"</span>));</span><br><span class="line">      index = i;</span><br><span class="line">      <span class="keyword">let</span> fn = middleware[i];</span><br><span class="line">      <span class="comment">// 运行到最后一个中间件时，调用参数 next</span></span><br><span class="line">      <span class="keyword">if</span> (i === middleware.length) fn = next;</span><br><span class="line">      <span class="keyword">if</span> (!fn) <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行当前中间件，把 ctx 和 next（ 也就是dispatch(i + 1) ）传入，执行 dispatch(i + 1) 就会进入下一个中间件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(fn(context, dispatch.bind(<span class="literal">null</span>, i + <span class="number">1</span>)));</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中间件内去调用 next 方法就是调用<code>dispatch(i + 1)</code>，即执行下一个中间件（入栈），以此类推执行到最后一个中间件（所有中间件入栈）。当最后一个中间件执行完毕，出栈，然后执行前一个中间件的处理函数，以此类推执行到第一个中间件出栈。<br>其实就是执行层层嵌套的函数，这个和 express 一样，但是 koa 的中间件模式为洋葱型，express 为直线型。这因为考虑异步中间件的情况，koa 的 next 方法会返回一个 promise 实例，因此使用<code>await next()</code>可以用同步的写法处理异步中间件。express 的 next 方法只是遍历 stack 找出并执行匹配的中间件，而没有返回 promise 实例，所以无法使用<code>async/await</code>特性，在处理异步中间件时，只能是线性的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个 koa 洋葱模型的例子</span></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">"koa"</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">  <span class="keyword">const</span> ms = <span class="built_in">Date</span>.now() - start;</span><br><span class="line">  ctx.set(<span class="string">"X-Response-Time"</span>, <span class="string">`<span class="subst">$&#123;ms&#125;</span>ms`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">  <span class="keyword">const</span> ms = <span class="built_in">Date</span>.now() - start;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;ctx.method&#125;</span> <span class="subst">$&#123;ctx.url&#125;</span> - <span class="subst">$&#123;ms&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="string">"Hello World"</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>结合具体案例来看一下，<code>compose</code>函数的作用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> middleware = [</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">ctx, next</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo1"</span>);</span><br><span class="line">    next();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo2"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">ctx, next</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"bar1"</span>);</span><br><span class="line">    next();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"bar2"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">var</span> fn = compose(middleware);</span><br></pre></td></tr></table></figure><p>此时 fn 可以视为下面的函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(foo(context, bar(context, () =&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve()</span><br><span class="line">    &#125;)));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以当执行<code>fn(ctx).then(handleResponse).catch(onerror);</code>时，输出如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo1;</span><br><span class="line">bar1;</span><br><span class="line">bar2;</span><br><span class="line">foo2;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/koajs/koa&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Koa2 的源码&lt;/a&gt; 相当的简短，因为抽离了路由、模板引擎等模块，只提供一个架子，而几乎所有的功能都需要由第三方中间件完成。阅读时建议对照源码。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;. lib&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── application.js  ---------- 构造 app 对象&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── context.js  -------------- 构造 ctx 对象&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── request.js --------------- 构造 req 对象&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;└── response.js  ------------- 构造 res 对象&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;底层原理同 express，即代理&lt;code&gt;http.createServer(requestHandler)&lt;/code&gt;中的&lt;code&gt;requestHandler&lt;/code&gt;，使用中间件来处理请求。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="https://hangermeng.top/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>express源码学习</title>
    <link href="https://hangermeng.top/2019/03/16/express%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>https://hangermeng.top/2019/03/16/express源码学习/</id>
    <published>2019-03-16T02:07:10.000Z</published>
    <updated>2021-01-19T06:42:29.025Z</updated>
    
    <content type="html"><![CDATA[<p>打开 <a href="https://github.com/expressjs/express" target="_blank" rel="noopener">Express4 的源码</a>，目录结构很清晰，阅读时建议对照源码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">. lib</span><br><span class="line">├── middleware  -------------- 中间件</span><br><span class="line">    ├── init.js   ------------ 增强 req 对象和 res 对象</span><br><span class="line">    └── query.js  ------------ 添加 req.query</span><br><span class="line">├── router  ------------------ 路由</span><br><span class="line">    ├── index.js  ------------ Router 构造器</span><br><span class="line">    ├── layer.js  ------------ 中间件和路由的抽象</span><br><span class="line">    └── route.js  ------------ 实现 router.route</span><br><span class="line">├── application.js  ---------- app 对象拓展</span><br><span class="line">├── express.js  -------------- 项目入口</span><br><span class="line">├── request.js --------------- req 对象拓展</span><br><span class="line">├── response.js  ------------- res 对象拓展</span><br><span class="line">├── utils.js  ---------------- 工具集</span><br><span class="line">└── view.js  ----------------- 模板引擎</span><br></pre></td></tr></table></figure><h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><p>Express 框架建立在 node.js 内置的 http 模块上，http 模块生成服务器的原始代码如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">  response.writeHead(<span class="number">200</span>, &#123; <span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span> &#125;);</span><br><span class="line">  response.end(<span class="string">"Hello world!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="string">"localhost"</span>);</span><br></pre></td></tr></table></figure><p>Express 代理了<code>http.createServer(requestHandler)</code>中的<code>requestHandler</code>，并使用注册后的中间件和路由，匹配响应传来的用户请求。</p><a id="more"></a><h3 id="代码梳理"><a href="#代码梳理" class="headerlink" title="代码梳理"></a>代码梳理</h3><p>下面是一个简单的 Express 使用案例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="comment">// first step</span></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// second step</span></span><br><span class="line">app.get(<span class="string">"/"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">"Hello world!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// third step</span></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><h4 id="third-step"><a href="#third-step" class="headerlink" title="third step"></a>third step</h4><p>app.listen 方法在 <code>application.js</code> 中被定义。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// application.js</span></span><br><span class="line">app.listen = <span class="function"><span class="keyword">function</span> <span class="title">listen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> server = http.createServer(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">return</span> server.listen.apply(server, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>启动一个服务，并指定监听端口，这里的关键是<code>http.createServer(this)</code>中的<code>this</code>（也就是<code>app</code>），即<code>http.createServer(requestHandler)</code>中的<code>requestHandler</code>，<code>this</code>应该是一个函数<code>(request, response) =&gt; {}</code>，下面介绍 express 如何改造这个函数。</p><h4 id="first-step"><a href="#first-step" class="headerlink" title="first step"></a>first step</h4><p>express 方法就是 <code>express.js</code> 中的 createApplication 方法，该方法返回了一个函数，即<code>requestHandler</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// express.js</span></span><br><span class="line"><span class="keyword">var</span> proto = <span class="built_in">require</span>(<span class="string">"./application"</span>);</span><br><span class="line"><span class="keyword">var</span> req = <span class="built_in">require</span>(<span class="string">"./request"</span>);</span><br><span class="line"><span class="keyword">var</span> res = <span class="built_in">require</span>(<span class="string">"./response"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createApplication</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> app = <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    app.handle(req, res, next);</span><br><span class="line">  &#125;;</span><br><span class="line">  mixin(app, EventEmitter.prototype, <span class="literal">false</span>);</span><br><span class="line">  <span class="comment">// 混入 application 中的属性，其中包括 app.handle 、app.init、app.get、app.listen</span></span><br><span class="line">  mixin(app, proto, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 暴露增强后的 req 对象，会在 middleware/init.js 中被用到</span></span><br><span class="line">  app.request = <span class="built_in">Object</span>.create(req, &#123;</span><br><span class="line">    app: &#123; <span class="attr">configurable</span>: <span class="literal">true</span>, <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">value</span>: app &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 暴露增强后的 res 对象，会在 middleware/init.js 中被用到</span></span><br><span class="line">  app.response = <span class="built_in">Object</span>.create(res, &#123;</span><br><span class="line">    app: &#123; <span class="attr">configurable</span>: <span class="literal">true</span>, <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">value</span>: app &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// app.init 内部调用 app.defaultConfiguration ，初始化配置项</span></span><br><span class="line">  app.init();</span><br><span class="line">  <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// application.js</span></span><br><span class="line">app.init = <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.cache = &#123;&#125;; <span class="comment">// 存储缓存的对象</span></span><br><span class="line">  <span class="keyword">this</span>.engines = &#123;&#125;; <span class="comment">// 存储模板引擎中扩展名和渲染函数的对应关系</span></span><br><span class="line">  <span class="keyword">this</span>.settings = &#123;&#125;; <span class="comment">// 存储 app.set 和 app.get 处理的对象</span></span><br><span class="line">  <span class="comment">// 设置默认的配置项</span></span><br><span class="line">  <span class="keyword">this</span>.defaultConfiguration();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="second-step"><a href="#second-step" class="headerlink" title="second step"></a>second step</h4><p>app.get 方法在 <code>application.js</code> 中被定义。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// application.js</span></span><br><span class="line"><span class="keyword">var</span> methods = <span class="built_in">require</span>(<span class="string">"methods"</span>);</span><br><span class="line"><span class="keyword">var</span> Router = <span class="built_in">require</span>(<span class="string">"./router"</span>);</span><br><span class="line"><span class="keyword">var</span> middleware = <span class="built_in">require</span>(<span class="string">"./middleware/init"</span>);</span><br><span class="line"><span class="keyword">var</span> query = <span class="built_in">require</span>(<span class="string">"./middleware/query"</span>);</span><br><span class="line"></span><br><span class="line">methods.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">  app[method] = <span class="function"><span class="keyword">function</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (method === <span class="string">"get"</span> &amp;&amp; <span class="built_in">arguments</span>.length === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// app.get(setting)</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.set(path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.lazyrouter();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> route = <span class="keyword">this</span>._router.route(path);</span><br><span class="line">    route[method].apply(route, slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// lazily adds the base router if it has not yet been added.</span></span><br><span class="line">app.lazyrouter = <span class="function"><span class="keyword">function</span> <span class="title">lazyrouter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>._router) &#123;</span><br><span class="line">    <span class="keyword">this</span>._router = <span class="keyword">new</span> Router(&#123;</span><br><span class="line">      caseSensitive: <span class="keyword">this</span>.enabled(<span class="string">"case sensitive routing"</span>),</span><br><span class="line">      strict: <span class="keyword">this</span>.enabled(<span class="string">"strict routing"</span>)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>._router.use(query(<span class="keyword">this</span>.get(<span class="string">"query parser fn"</span>)));</span><br><span class="line">    <span class="keyword">this</span>._router.use(middleware.init(<span class="keyword">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// router/index.js</span></span><br><span class="line"><span class="keyword">var</span> Layer = <span class="built_in">require</span>(<span class="string">"./layer"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.use 的实质</span></span><br><span class="line">proto.use = <span class="function"><span class="keyword">function</span> <span class="title">use</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... 省略部分代码</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; callbacks.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> fn = callbacks[i];</span><br><span class="line">    <span class="keyword">var</span> layer = <span class="keyword">new</span> Layer(</span><br><span class="line">      path,</span><br><span class="line">      &#123;</span><br><span class="line">        sensitive: <span class="keyword">this</span>.caseSensitive,</span><br><span class="line">        strict: <span class="literal">false</span>,</span><br><span class="line">        end: <span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">      fn</span><br><span class="line">    );</span><br><span class="line">    layer.route = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// 将 layer 对象推入 stack 中管理</span></span><br><span class="line">    <span class="keyword">this</span>.stack.push(layer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一个 Layer 对象包含一个路径和回调，它会把路径正则表达式化，在响应请求时用来匹配路径。在<code>app.lazyrouter</code>方法里添加了一个中间件<code>middleware.init(this)</code>，重新设置了 req 和 res 的原型，增加了许多方法，详见<code>request.js</code>和<code>response.js</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// request.js</span></span><br><span class="line"><span class="keyword">var</span> req = <span class="built_in">Object</span>.create(http.IncomingMessage.prototype);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// response.js</span></span><br><span class="line"><span class="keyword">var</span> res = <span class="built_in">Object</span>.create(http.ServerResponse.prototype);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// middleware/init.js</span></span><br><span class="line">exports.init = <span class="function"><span class="keyword">function</span>(<span class="params">app</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">expressInit</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (app.enabled(<span class="string">"x-powered-by"</span>)) res.setHeader(<span class="string">"X-Powered-By"</span>, <span class="string">"Express"</span>);</span><br><span class="line">    req.res = res;</span><br><span class="line">    res.req = req;</span><br><span class="line">    req.next = next;</span><br><span class="line"></span><br><span class="line">    setPrototypeOf(req, app.request);</span><br><span class="line">    setPrototypeOf(res, app.response);</span><br><span class="line"></span><br><span class="line">    res.locals = res.locals || <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    next();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="响应请求阶段"><a href="#响应请求阶段" class="headerlink" title="响应请求阶段"></a>响应请求阶段</h4><p><code>app.handle</code> 实质上是调用了自身 router 的 handle，<code>router.handle</code> 遍历 router 维护的 stack 数组，找到匹配路径的 layer 对象。对于中间件 layer（<code>layer.route</code> 为 <code>undefined</code>），匹配成功后就执行中间件函数；对于路由 layer（<code>layer.route</code> 不是 <code>undefined</code>），匹配成功后还需要匹配 http method 才能执行路由函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// router/index.js</span></span><br><span class="line">proto.handle = <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">req, res, out</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> idx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> protohost = getProtohost(req.url) || <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">var</span> removed = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">var</span> slashAdded = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">var</span> paramcalled = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// store options for OPTIONS request</span></span><br><span class="line">  <span class="comment">// only used if OPTIONS request</span></span><br><span class="line">  <span class="keyword">var</span> options = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// middleware and routes</span></span><br><span class="line">  <span class="keyword">var</span> stack = self.stack;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// manage inter-router variables</span></span><br><span class="line">  <span class="keyword">var</span> parentParams = req.params;</span><br><span class="line">  <span class="keyword">var</span> parentUrl = req.baseUrl || <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">var</span> done = restore(out, req, <span class="string">"baseUrl"</span>, <span class="string">"next"</span>, <span class="string">"params"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// setup next layer</span></span><br><span class="line">  req.next = next;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// for options requests, respond with a default if nothing else responds</span></span><br><span class="line">  <span class="keyword">if</span> (req.method === <span class="string">"OPTIONS"</span>) &#123;</span><br><span class="line">    done = wrap(done, <span class="function"><span class="keyword">function</span>(<span class="params">old, err</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err || options.length === <span class="number">0</span>) <span class="keyword">return</span> old(err);</span><br><span class="line">      sendOptionsResponse(res, options, old);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// setup basic req values</span></span><br><span class="line">  req.baseUrl = parentUrl;</span><br><span class="line">  req.originalUrl = req.originalUrl || req.url;</span><br><span class="line"></span><br><span class="line">  next();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ... 在下面介绍</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>next 函数内部有个 while 循环，每次循环都会从 stack 中拿出一个 layer，这个 layer 中包含了路由和中间件信息，然后就会用 layer 和请求的 path 进行匹配，如果匹配成功就会执行 layer.handle_request，调用中间件函数。但如果匹配失败，就会循环下一个 layer 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// router/index.js</span></span><br><span class="line"><span class="comment">// ... 省略部分代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 拿到当前的访问路径</span></span><br><span class="line">  <span class="keyword">var</span> path = getPathname(req);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// find next matching layer</span></span><br><span class="line">  <span class="keyword">var</span> layer;</span><br><span class="line">  <span class="keyword">var</span> match;</span><br><span class="line">  <span class="keyword">var</span> route;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (match !== <span class="literal">true</span> &amp;&amp; idx &lt; stack.length) &#123;</span><br><span class="line">    layer = stack[idx++];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行路径匹配，匹配返回 true，不匹配返回 false</span></span><br><span class="line">    match = matchLayer(layer, path);</span><br><span class="line">    route = layer.route;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (match !== <span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!route) &#123;</span><br><span class="line">      <span class="comment">// 正常处理非路由中间件</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> method = req.method;</span><br><span class="line">    <span class="keyword">var</span> has_method = route._handles_method(method);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// build up automatic options response</span></span><br><span class="line">    <span class="keyword">if</span> (!has_method &amp;&amp; method === <span class="string">"OPTIONS"</span>) &#123;</span><br><span class="line">      appendMethods(options, route._options());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// don't even bother matching route</span></span><br><span class="line">    <span class="keyword">if</span> (!has_method &amp;&amp; method !== <span class="string">"HEAD"</span>) &#123;</span><br><span class="line">      match = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ... 省略部分代码</span></span><br><span class="line">  <span class="comment">// this should be done for the layer</span></span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    layer.handle_error(err, req, res, next);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    layer.handle_request(req, res, next);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="路由中间件"><a href="#路由中间件" class="headerlink" title="路由中间件"></a>路由中间件</h3><p>当请求来时，会执行 handle，循环 stack，发现 path 相同且 method 相同，则调用对应 callback。当路由不断增多，stack 数组会不断增大，匹配效率必然下降，为了提高效率，express 引入了 route ，也就是路由中间件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个案例</span></span><br><span class="line"><span class="keyword">var</span> route = app</span><br><span class="line">  .route(<span class="string">"/list"</span>)</span><br><span class="line">  .get(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.end(<span class="string">"hello get"</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .post(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.end(<span class="string">"hello post"</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .put(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.end(<span class="string">"hello put"</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .delete(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.end(<span class="string">"hello delete"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">app.use(<span class="string">"/"</span>, routers);</span><br></pre></td></tr></table></figure><p><code>app.route</code>在<code>application.js</code>中被定义，内部调用了 router 的 route 方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// router/index.js</span></span><br><span class="line"><span class="keyword">var</span> Route = <span class="built_in">require</span>(<span class="string">"./route"</span>);</span><br><span class="line"></span><br><span class="line">proto.route = <span class="function"><span class="keyword">function</span> <span class="title">route</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> route = <span class="keyword">new</span> Route(path);</span><br><span class="line">  <span class="comment">// 把 route 里面的 dispatch 方法作为 Layer 的处理函数</span></span><br><span class="line">  <span class="keyword">var</span> layer = <span class="keyword">new</span> Layer(</span><br><span class="line">    path,</span><br><span class="line">    &#123;</span><br><span class="line">      sensitive: <span class="keyword">this</span>.caseSensitive,</span><br><span class="line">      strict: <span class="keyword">this</span>.strict,</span><br><span class="line">      end: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    route.dispatch.bind(route)</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  layer.route = route;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.stack.push(layer);</span><br><span class="line">  <span class="comment">// 返回route实例，用于链式调用，注册 method 方法</span></span><br><span class="line">  <span class="keyword">return</span> route;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当 layer 的路径匹配成功，就会交给 route 来匹配 method，route 存放了所有注册的方法名，可以快速匹配是否有注册该方法，如果有则执行回调函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// router/route.js</span></span><br><span class="line">Route.prototype.dispatch = <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">req, res, done</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> idx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> stack = <span class="keyword">this</span>.stack;</span><br><span class="line">  <span class="keyword">if</span> (stack.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> done();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> method = req.method.toLowerCase();</span><br><span class="line">  <span class="keyword">if</span> (method === <span class="string">"head"</span> &amp;&amp; !<span class="keyword">this</span>.methods[<span class="string">"head"</span>]) &#123;</span><br><span class="line">    method = <span class="string">"get"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  req.route = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  next();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 处理退出 route 信号</span></span><br><span class="line">    <span class="keyword">if</span> (err &amp;&amp; err === <span class="string">"route"</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> done();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理退出 router 信号</span></span><br><span class="line">    <span class="keyword">if</span> (err &amp;&amp; err === <span class="string">"router"</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> done(err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过递归调用 next，遍历 stack</span></span><br><span class="line">    <span class="keyword">var</span> layer = stack[idx++];</span><br><span class="line">    <span class="keyword">if</span> (!layer) &#123;</span><br><span class="line">      <span class="keyword">return</span> done(err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (layer.method &amp;&amp; layer.method !== method) &#123;</span><br><span class="line">      <span class="keyword">return</span> next(err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      layer.handle_error(err, req, res, next);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      layer.handle_request(req, res, next);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>next(err)</code>将控制权传递到错误处理中间件，当调用<code>next(err)</code>时，实质是调用<code>layer.handle_error</code>，如果 fn 的参数不足 4 个，认为不是一个标准的错误处理中间件，则继续调用<code>next(err)</code>，直到参数达到 4 个，执行错误处理中间件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// router/layer.js</span></span><br><span class="line">Layer.prototype.handle_request = <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fn = <span class="keyword">this</span>.handle; <span class="comment">// 回调函数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fn.length &gt; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="comment">// 形参数量大于 3，则认为不是一个标准的 requestHandler，调用 next 去查找下一个 layer</span></span><br><span class="line">    <span class="keyword">return</span> next();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行标准的 requestHandler</span></span><br><span class="line">    fn(req, res, next);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    next(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Layer.prototype.handle_error = <span class="function"><span class="keyword">function</span> <span class="title">handle_error</span>(<span class="params">error, req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> fn = <span class="keyword">this</span>.handle; <span class="comment">// 中间件函数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fn.length !== <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> next(error);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    fn(error, req, res, next);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    next(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="模板渲染"><a href="#模板渲染" class="headerlink" title="模板渲染"></a>模板渲染</h3><p>下面是使用模板引擎的写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定模板文件所在目录</span></span><br><span class="line">app.set(<span class="string">"views"</span>, <span class="string">"./views"</span>);</span><br><span class="line"><span class="comment">// 指定要使用的模板引擎</span></span><br><span class="line">app.set(<span class="string">"view engine"</span>, <span class="string">"pug"</span>);</span><br><span class="line">app.get(<span class="string">"/"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.render(<span class="string">"home"</span>, &#123; <span class="attr">title</span>: <span class="string">"Hey"</span>, <span class="attr">message</span>: <span class="string">"Hello there!"</span> &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>res.render</code>实际调用的是<code>app.render</code>，内部创建 View 实例，并调用<code>view.render(options, callback)</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// response.js</span></span><br><span class="line">res.render = <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">view, options, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> app = <span class="keyword">this</span>.req.app;</span><br><span class="line">  <span class="keyword">var</span> opts = options || &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> done = callback;</span><br><span class="line">  <span class="comment">//  ...省略部分代码</span></span><br><span class="line">  <span class="comment">// default callback to respond</span></span><br><span class="line">  done =</span><br><span class="line">    done ||</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">err, str</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> req.next(err);</span><br><span class="line">      self.send(str);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// render</span></span><br><span class="line">  app.render(view, opts, done);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// application.js</span></span><br><span class="line">app.render = <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">name, options, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cache = <span class="keyword">this</span>.cache;</span><br><span class="line">  <span class="keyword">var</span> done = callback;</span><br><span class="line">  <span class="keyword">var</span> engines = <span class="keyword">this</span>.engines;</span><br><span class="line">  <span class="keyword">var</span> opts = options;</span><br><span class="line">  <span class="keyword">var</span> renderOptions = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> view;</span><br><span class="line">  <span class="comment">//  ...省略部分代码</span></span><br><span class="line">  <span class="keyword">if</span> (!view) &#123;</span><br><span class="line">    <span class="keyword">var</span> View = <span class="keyword">this</span>.get(<span class="string">"view"</span>);</span><br><span class="line"></span><br><span class="line">    view = <span class="keyword">new</span> View(name, &#123;</span><br><span class="line">      defaultEngine: <span class="keyword">this</span>.get(<span class="string">"view engine"</span>),</span><br><span class="line">      root: <span class="keyword">this</span>.get(<span class="string">"views"</span>),</span><br><span class="line">      engines: engines</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// prime the cache</span></span><br><span class="line">    <span class="keyword">if</span> (renderOptions.cache) &#123;</span><br><span class="line">      cache[name] = view;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// render</span></span><br><span class="line">  tryRender(view, renderOptions, done);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tryRender</span>(<span class="params">view, options, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    view.render(options, callback);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    callback(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// view.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">View</span>(<span class="params">name, options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//  ...省略部分代码</span></span><br><span class="line">  <span class="keyword">var</span> opts = options || &#123;&#125;;</span><br><span class="line">  <span class="keyword">this</span>.ext = extname(name);</span><br><span class="line">  <span class="comment">// 如果对应后缀的模板引擎没有被注册</span></span><br><span class="line">  <span class="keyword">if</span> (!opts.engines[<span class="keyword">this</span>.ext]) &#123;</span><br><span class="line">    <span class="keyword">var</span> mod = <span class="keyword">this</span>.ext.substr(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 使用 require() 去加载没有被注册的模板引擎</span></span><br><span class="line">    <span class="keyword">var</span> fn = <span class="built_in">require</span>(mod).__express;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">"function"</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Module "'</span> + mod + <span class="string">'" does not provide a view engine.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注册模板引擎</span></span><br><span class="line">    opts.engines[<span class="keyword">this</span>.ext] = fn;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 保存需要的模板引擎</span></span><br><span class="line">  <span class="keyword">this</span>.engine = opts.engines[<span class="keyword">this</span>.ext];</span><br><span class="line">  <span class="comment">// 拿到文件的绝对路径</span></span><br><span class="line">  <span class="keyword">this</span>.path = <span class="keyword">this</span>.lookup(fileName);</span><br><span class="line">&#125;</span><br><span class="line">View.prototype.render = <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">options, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 调用模板引擎的函数，调用完就执行 callback</span></span><br><span class="line">  <span class="keyword">this</span>.engine(<span class="keyword">this</span>.path, options, callback);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;打开 &lt;a href=&quot;https://github.com/expressjs/express&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Express4 的源码&lt;/a&gt;，目录结构很清晰，阅读时建议对照源码。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;. lib&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── middleware  -------------- 中间件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ├── init.js   ------------ 增强 req 对象和 res 对象&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    └── query.js  ------------ 添加 req.query&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── router  ------------------ 路由&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ├── index.js  ------------ Router 构造器&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ├── layer.js  ------------ 中间件和路由的抽象&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    └── route.js  ------------ 实现 router.route&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── application.js  ---------- app 对象拓展&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── express.js  -------------- 项目入口&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── request.js --------------- req 对象拓展&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── response.js  ------------- res 对象拓展&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── utils.js  ---------------- 工具集&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;└── view.js  ----------------- 模板引擎&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;底层原理&quot;&gt;&lt;a href=&quot;#底层原理&quot; class=&quot;headerlink&quot; title=&quot;底层原理&quot;&gt;&lt;/a&gt;底层原理&lt;/h3&gt;&lt;p&gt;Express 框架建立在 node.js 内置的 http 模块上，http 模块生成服务器的原始代码如下。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; http = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;http&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; app = http.createServer(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;request, response&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  response.writeHead(&lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;, &amp;#123; &lt;span class=&quot;string&quot;&gt;&quot;Content-Type&quot;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&quot;text/plain&quot;&lt;/span&gt; &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  response.end(&lt;span class=&quot;string&quot;&gt;&quot;Hello world!&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;app.listen(&lt;span class=&quot;number&quot;&gt;3000&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;localhost&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Express 代理了&lt;code&gt;http.createServer(requestHandler)&lt;/code&gt;中的&lt;code&gt;requestHandler&lt;/code&gt;，并使用注册后的中间件和路由，匹配响应传来的用户请求。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="https://hangermeng.top/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>Promise实现</title>
    <link href="https://hangermeng.top/2019/03/11/Promise%E5%AE%9E%E7%8E%B0/"/>
    <id>https://hangermeng.top/2019/03/11/Promise实现/</id>
    <published>2019-03-11T08:33:57.000Z</published>
    <updated>2021-01-19T06:42:29.019Z</updated>
    
    <content type="html"><![CDATA[<p>首先实现一个基础结构，每一个 Promise 实现，都有状态标识，以及存放成功与失败回调函数的数组。为什么要使用<strong>数组</strong>来存放回调函数呢，是考虑到了下面这种情况。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 连续调用多次 p3.then ，回调函数需要使用数组来存放</span></span><br><span class="line">p3.then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"a: "</span> + v));</span><br><span class="line">p3.then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"b: "</span> + v));</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  self.status = <span class="string">"pending"</span>; <span class="comment">// promise 的状态</span></span><br><span class="line">  self.onResolvedCallback = []; <span class="comment">// 存放成功的回调函数的数组</span></span><br><span class="line">  self.onRejectedCallback = []; <span class="comment">// 存放失败的回调函数的数组</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// todo</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// todo</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    executor(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">    reject(reason);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>resolve/reject</code> 负责异步修改 promise 的状态并触发 <code>onResolvedCallback/onRejectedCallback</code> 中的回调函数。为什么要<strong>异步</strong>触发呢，是为了保证在触发回调前，所有的回调函数都已经被 then 注册。</p><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value.then(resolve, reject);</span><br><span class="line">  &#125;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (self.status === <span class="string">"pending"</span>) &#123;</span><br><span class="line">      self.status = <span class="string">"resolved"</span>;</span><br><span class="line">      self.data = value;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; self.onResolvedCallback.length; i++) &#123;</span><br><span class="line">        self.onResolvedCallback[i](value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (self.status === <span class="string">"pending"</span>) &#123;</span><br><span class="line">      self.status = <span class="string">"rejected"</span>;</span><br><span class="line">      self.data = reason;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; self.onRejectedCallback.length; i++) &#123;</span><br><span class="line">        self.onRejectedCallback[i](reason);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们需要实现 then 方法，then 方法主要的作用是为实例注册回调函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onResolved, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> promise2;</span><br><span class="line">  onResolved =</span><br><span class="line">    <span class="keyword">typeof</span> onResolved === <span class="string">"function"</span></span><br><span class="line">      ? onResolved</span><br><span class="line">      : <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> v;</span><br><span class="line">        &#125;;</span><br><span class="line">  onRejected =</span><br><span class="line">    <span class="keyword">typeof</span> onRejected === <span class="string">"function"</span></span><br><span class="line">      ? onRejected</span><br><span class="line">      : <span class="function"><span class="keyword">function</span>(<span class="params">r</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">throw</span> r;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.status === <span class="string">"resolved"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 保证 then 方法先被执行</span></span><br><span class="line">        execute(promise2, self.data, onResolved, resolve, reject);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.status === <span class="string">"rejected"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 保证 then 方法先被执行</span></span><br><span class="line">        execute(promise2, self.data, onRejected, resolve, reject);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.status === <span class="string">"pending"</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里之所以没有异步执行，是因为这些函数必然会被resolve或reject调用，而resolve或reject函数里的内容是异步执行的</span></span><br><span class="line">    <span class="keyword">return</span> (promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      self.onResolvedCallback.push(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        execute(promise2, value, onResolved, resolve, reject);</span><br><span class="line">      &#125;);</span><br><span class="line">      self.onRejectedCallback.push(<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">        execute(promise2, reason, onRejected, resolve, reject);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// promise2 = promise1.then(onResolved, onRejected)</span></span><br><span class="line"><span class="comment">// 执行回调，并根据返回值决定 promise2 的状态</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">execute</span>(<span class="params">promise2, val, callback, resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x = callback(val);</span><br><span class="line">    resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (r) &#123;</span><br><span class="line">    reject(r);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>onResolved/onRejected</code>的返回值 x 会有多种情况，如果是 Promise 实例，直接使用 <code>x.then(resolve, reject)</code>即可；如果是一个 thenable 对象，尝试去执行对象的 then 方法；如果是原始类型或者非 thenable 对象，直接执行<code>resolve(x)</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">resolvePromise函数根据 x 的值来决定 promise2 的状态</span></span><br><span class="line"><span class="comment">x为`promise2 = promise1.then(onResolved, onRejected)`里`onResolved/onRejected`的返回值，</span></span><br><span class="line"><span class="comment">`resolve`和`reject`实际上是`promise2`的`executor`的两个实参。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> then;</span><br><span class="line">  <span class="keyword">var</span> thenCalledOrThrow = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (promise2 === x) &#123;</span><br><span class="line">    <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Chaining cycle detected for promise!"</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">    x.then(resolve, reject);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 处理 thenable 对象</span></span><br><span class="line">  <span class="keyword">if</span> (x !== <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">"object"</span> || <span class="keyword">typeof</span> x === <span class="string">"function"</span>)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      then = x.then; <span class="comment">// because x.then could be a getter</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">"function"</span>) &#123;</span><br><span class="line">        then.call(</span><br><span class="line">          x,</span><br><span class="line">          <span class="function"><span class="keyword">function</span> <span class="title">rs</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (thenCalledOrThrow) <span class="keyword">return</span>;</span><br><span class="line">            thenCalledOrThrow = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> resolvePromise(promise2, y, resolve, reject);</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="function"><span class="keyword">function</span> <span class="title">rj</span>(<span class="params">r</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (thenCalledOrThrow) <span class="keyword">return</span>;</span><br><span class="line">            thenCalledOrThrow = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> reject(r);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(x);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (thenCalledOrThrow) <span class="keyword">return</span>;</span><br><span class="line">      thenCalledOrThrow = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">return</span> reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    resolve(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写到这里其实已经实现了 promise 的核心功能了，我们可以写一段代码测试一下了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">1</span>); <span class="comment">// 改变的是 p 的状态</span></span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">  <span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(value + <span class="number">2</span>); <span class="comment">// 改变的是 p2 的状态</span></span><br><span class="line">    &#125;, <span class="number">200</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> p2;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> <span class="title">foo2</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>执行以上代码会依次输出<code>1</code>和<code>3</code>, 执行顺序如下：</p><ol><li>p.then 注册 foo 且返回 x，x.then 注册 foo2 且返回 x2</li><li>100ms 后执行<code>resolve(1)</code>，p 的状态变更为<code>&#39;resolved&#39;</code>并异步执行<code>foo(1)</code>，打印出<code>1</code></li><li>foo 返回 p2 , 由于 p2 是 Promise 实例，执行 p2.then(x_resolve, x_reject) 即注册了 x 的 resolve 函数</li><li>200ms 后执行<code>resolve(value + 2)</code> ，p2 的状态变更为<code>&#39;resolved&#39;</code>并异步执行<code>x_resolve(3)</code></li><li>x 的状态变更为<code>&#39;resolved&#39;</code>并异步执行<code>foo2(3)</code>，打印出<code>3</code></li></ol><h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><p>根据已经实现的实例方法 then，可以很容易地实现 catch 和 finally 实例方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.catch = <span class="function"><span class="keyword">function</span>(<span class="params">onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.then(<span class="literal">null</span>, onRejected);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>finally 里的函数不管状态如何都会被执行，所以只需要成功和失败两种情况各写一次。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.finally = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">      setTimeout(fn);</span><br><span class="line">      <span class="keyword">return</span> v;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">r</span>) </span>&#123;</span><br><span class="line">      setTimeout(fn);</span><br><span class="line">      <span class="keyword">throw</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><h4 id="Promise-resolve-amp-Promise-reject"><a href="#Promise-resolve-amp-Promise-reject" class="headerlink" title="Promise.resolve &amp; Promise.reject"></a>Promise.resolve &amp; Promise.reject</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolvePromise(promise, value, resolve, reject);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.reject = <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    reject(reason);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h4><p><code>Promise.race</code>返回一个 promise （记为 r），只要传入的其中一个 promise 状态变为成功时，就执行 r 的 resolve 方法，否则执行 r 的 reject 方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">      <span class="built_in">Promise</span>.resolve(promises[i]).then(</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> resolve(value);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> reject(reason);</span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h4><p><code>Promise.all</code>返回一个 promise （记为 a），只有当传入的所有 promise 状态都为成功时，才执行 a 的 resolve 方法，否则执行 a 的 reject 方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> resolvedCounter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> promiseNum = promises.length;</span><br><span class="line">    <span class="keyword">var</span> resolvedValues = <span class="keyword">new</span> <span class="built_in">Array</span>(promiseNum); <span class="comment">// 存放所有 promise 的执行结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; promiseNum; i++) &#123;</span><br><span class="line">      (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">Promise</span>.resolve(promises[i]).then(</span><br><span class="line">          <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">            resolvedCounter++;</span><br><span class="line">            resolvedValues[i] = value;</span><br><span class="line">            <span class="comment">// 只有当所有 promise 状态都为成功时，才将 a 的状态变更为'resolved'</span></span><br><span class="line">            <span class="keyword">if</span> (resolvedCounter === promiseNum) &#123;</span><br><span class="line">              <span class="keyword">return</span> resolve(resolvedValues);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> reject(reason);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125;)(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>Promise.all</code>存在一个缺陷，只要其中一个 promise 状态为失败，就拿不到其他成功状态的 promise 。现在有一个需求，实现一个 <code>Promise.alwayResolve(promises)</code> 方法，总是返回一个成功状态的 promise，返回值为一个存放非 pending 状态的 promises 的数组，只需要改变一下<code>Promise.all</code>就可以了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.alwayResolve = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> resolvedCounter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> promiseNum = promises.length;</span><br><span class="line">    <span class="keyword">var</span> resolvedValues = <span class="keyword">new</span> <span class="built_in">Array</span>(promiseNum);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; promiseNum; i++) &#123;</span><br><span class="line">      (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">Promise</span>.resolve(promises[i]).then(</span><br><span class="line">          <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">            resolvedCounter++;</span><br><span class="line">            resolvedValues[i] = value;</span><br><span class="line">            <span class="keyword">if</span> (resolvedCounter === promiseNum) &#123;</span><br><span class="line">              <span class="keyword">return</span> resolve(resolvedValues);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">            resolvedCounter++;</span><br><span class="line">            resolvedValues[i] = reason;</span><br><span class="line">            <span class="keyword">if</span> (resolvedCounter === promiseNum) &#123;</span><br><span class="line">              <span class="keyword">return</span> resolve(resolvedValues);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125;)(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先实现一个基础结构，每一个 Promise 实现，都有状态标识，以及存放成功与失败回调函数的数组。为什么要使用&lt;strong&gt;数组&lt;/strong&gt;来存放回调函数呢，是考虑到了下面这种情况。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; p3 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  setTimeout(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    resolve(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Date&lt;/span&gt;());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;, &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 连续调用多次 p3.then ，回调函数需要使用数组来存放&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p3.then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;v&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&quot;a: &quot;&lt;/span&gt; + v));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p3.then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;v&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&quot;b: &quot;&lt;/span&gt; + v));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;executor&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; self = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  self.status = &lt;span class=&quot;string&quot;&gt;&quot;pending&quot;&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// promise 的状态&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  self.onResolvedCallback = []; &lt;span class=&quot;comment&quot;&gt;// 存放成功的回调函数的数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  self.onRejectedCallback = []; &lt;span class=&quot;comment&quot;&gt;// 存放失败的回调函数的数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;resolve&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;value&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// todo&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;reject&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;reason&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// todo&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    executor(resolve, reject);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (reason) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    reject(reason);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;resolve/reject&lt;/code&gt; 负责异步修改 promise 的状态并触发 &lt;code&gt;onResolvedCallback/onRejectedCallback&lt;/code&gt; 中的回调函数。为什么要&lt;strong&gt;异步&lt;/strong&gt;触发呢，是为了保证在触发回调前，所有的回调函数都已经被 then 注册。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://hangermeng.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>vuex工作原理</title>
    <link href="https://hangermeng.top/2019/01/14/vuex%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>https://hangermeng.top/2019/01/14/vuex工作原理/</id>
    <published>2019-01-14T03:03:07.000Z</published>
    <updated>2021-01-19T06:42:29.031Z</updated>
    
    <content type="html"><![CDATA[<p>vuex 中的 store 本质就是没有 template 的隐藏着的 vue 组件，所有配置的 state、actions、mutations 以及 getters 都是其组件的属性，所有的操作都是对这个组件进行的。</p><p>vuex 仅仅是作为 vue 的一个插件而存在，不像 Redux、MobX 等库可以应用于所有框架，vuex 只能使用在 vue 上，很大的程度是因为其高度依赖于 vue 的 computed 依赖检测系统以及其插件系统。</p><p>每一个 vue 插件都需要有一个公开的 install 方法，vuex 的 install 方法中调用了 applyMixin 方法，该方法在组件的 beforeCreate 生命周期中混入了一个操作：在实例上挂载了一个<code>$store</code>属性指向<code>store</code>对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/store.js</span></span><br><span class="line"><span class="keyword">import</span> applyMixin <span class="keyword">from</span> <span class="string">"./mixin"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">install</span>(<span class="params">_Vue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Vue &amp;&amp; _Vue === Vue) &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">"production"</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(</span><br><span class="line">        <span class="string">"[vuex] already installed. Vue.use(Vuex) should be called only once."</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Vue = _Vue;</span><br><span class="line">  applyMixin(Vue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/mixins.js</span></span><br><span class="line"><span class="comment">// 对应 applyMixin 方法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">Vue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> version = <span class="built_in">Number</span>(Vue.version.split(<span class="string">"."</span>)[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (version &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">    Vue.mixin(&#123; <span class="attr">beforeCreate</span>: vuexInit &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> _init = Vue.prototype._init;</span><br><span class="line">    Vue.prototype._init = <span class="function"><span class="keyword">function</span>(<span class="params">options = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">      options.init = options.init ? [vuexInit].concat(options.init) : vuexInit;</span><br><span class="line">      _init.call(<span class="keyword">this</span>, options);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Vuex init hook, injected into each instances init hooks list.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">vuexInit</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> options = <span class="keyword">this</span>.$options;</span><br><span class="line">    <span class="comment">// store injection</span></span><br><span class="line">    <span class="keyword">if</span> (options.store) &#123;</span><br><span class="line">      <span class="keyword">this</span>.$store =</span><br><span class="line">        <span class="keyword">typeof</span> options.store === <span class="string">"function"</span> ? options.store() : options.store;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options.parent &amp;&amp; options.parent.$store) &#123;</span><br><span class="line">      <span class="keyword">this</span>.$store = options.parent.$store;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们一般像下面这样使用 vuex :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Vue.use(Vuex);</span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state,</span><br><span class="line">  mutations,</span><br><span class="line">  actions,</span><br><span class="line">  modules</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 此时 store 等于 this.$options.store</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">"#app"</span>,</span><br><span class="line">  store</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在 Vuex.Store 这个构造函数中，会执行<code>resetStoreVM(this, state)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/store.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resetStoreVM</span>(<span class="params">store, state, hot</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 省略无关代码</span></span><br><span class="line">  store._vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">      $$state: state</span><br><span class="line">    &#125;,</span><br><span class="line">    computed</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出，其本质就是将我们传入的 state 作为一个隐藏的 vue 组件的 data，也就是说，我们的 commit 操作，本质上是修改这个组件的 data 。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;vuex 中的 store 本质就是没有 template 的隐藏着的 vue 组件，所有配置的 state、actions、mutations 以及 getters 都是其组件的属性，所有的操作都是对这个组件进行的。&lt;/p&gt;
&lt;p&gt;vuex 仅仅是作为 vue 的一个插件而存在，不像 Redux、MobX 等库可以应用于所有框架，vuex 只能使用在 vue 上，很大的程度是因为其高度依赖于 vue 的 computed 依赖检测系统以及其插件系统。&lt;/p&gt;
&lt;p&gt;每一个 vue 插件都需要有一个公开的 install 方法，vuex 的 install 方法中调用了 applyMixin 方法，该方法在组件的 beforeCreate 生命周期中混入了一个操作：在实例上挂载了一个&lt;code&gt;$store&lt;/code&gt;属性指向&lt;code&gt;store&lt;/code&gt;对象。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// src/store.js&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; applyMixin &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;./mixin&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;install&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;_Vue&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (Vue &amp;amp;&amp;amp; _Vue === Vue) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (process.env.NODE_ENV !== &lt;span class=&quot;string&quot;&gt;&quot;production&quot;&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.error(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&quot;[vuex] already installed. Vue.use(Vuex) should be called only once.&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Vue = _Vue;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  applyMixin(Vue);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Vue.js" scheme="https://hangermeng.top/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>python引入本地模块</title>
    <link href="https://hangermeng.top/2018/10/25/python%E5%BC%95%E5%85%A5%E6%9C%AC%E5%9C%B0%E6%A8%A1%E6%9D%BF/"/>
    <id>https://hangermeng.top/2018/10/25/python引入本地模板/</id>
    <published>2018-10-25T07:29:44.000Z</published>
    <updated>2021-01-19T06:42:29.029Z</updated>
    
    <content type="html"><![CDATA[<p>作为新手不熟悉<code>python</code>如何引入本地的模块，经过一番折腾，基本明白了引入方式。<br>假设有一个项目，目录结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">. root_dir</span><br><span class="line">├── app.py</span><br><span class="line">└── test</span><br><span class="line">    └── subtest</span><br><span class="line">        ├── __init__.py</span><br><span class="line">        └── hi.py</span><br><span class="line">    ├── __init__.py</span><br><span class="line">    └── hello.py</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># hello.py</span><br><span class="line">def hello():</span><br><span class="line">    print(&apos;hello world&apos;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># hi.py</span><br><span class="line">def hi():</span><br><span class="line">    print(&apos;hi world&apos;)</span><br></pre></td></tr></table></figure><p>需要在<code>app.py</code>中使用<code>hello()</code>和<code>hi()</code>这两个函数，引入方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># app.py</span><br><span class="line">from test import hello</span><br><span class="line">from test.subtest import hi</span><br><span class="line"></span><br><span class="line">hello.hello()</span><br><span class="line">hi.hi()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为新手不熟悉&lt;code&gt;python&lt;/code&gt;如何引入本地的模块，经过一番折腾，基本明白了引入方式。&lt;br&gt;假设有一个项目，目录结构如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;. root_dir&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;├── app.py&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;└── test&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    └── subtest&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ├── __init__.py&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        └── hi.py&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ├── __init__.py&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    └── hello.py&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="pyhton" scheme="https://hangermeng.top/tags/pyhton/"/>
    
  </entry>
  
  <entry>
    <title>vim使用总结</title>
    <link href="https://hangermeng.top/2018/10/18/vim%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>https://hangermeng.top/2018/10/18/vim使用总结/</id>
    <published>2018-10-18T08:38:44.000Z</published>
    <updated>2021-01-19T06:42:29.030Z</updated>
    
    <content type="html"><![CDATA[<p>vim 分为三种模式: 命令模式（Command mode）、输入模式（Insert mode）、底线命令模式（Last line mode），初始进入的是命令模式。</p><h3 id="命令模式下"><a href="#命令模式下" class="headerlink" title="命令模式下"></a>命令模式下</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>h</code>/<code>j</code>/<code>k</code>/<code>l</code></td><td>←/↓/↑/→</td></tr><tr><td><code>:</code></td><td>切换到底线命令模式</td></tr><tr><td><code>a</code></td><td>进入编辑模式，在光标后插入</td></tr><tr><td><code>i</code></td><td>进入编辑模式，在光标前插入</td></tr><tr><td><code>u</code></td><td>撤销，回到上一步操作</td></tr><tr><td><code>dd</code></td><td>删除本行</td></tr><tr><td><code>D</code></td><td>删除至行尾</td></tr><tr><td><code>w</code></td><td>下一个单词</td></tr><tr><td><code>b</code></td><td>上一个单词</td></tr><tr><td><code>e</code></td><td>光标到词尾</td></tr><tr><td><code>/</code> + 内容</td><td>查找内容，按<code>n</code>跳到下一项</td></tr></tbody></table><h3 id="编辑模式下"><a href="#编辑模式下" class="headerlink" title="编辑模式下"></a>编辑模式下</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>esc</code></td><td>进入命令模式</td></tr><tr><td><code>g</code> + <code>g</code></td><td>将光标快速移动到文件首</td></tr><tr><td><code>G</code></td><td>将光标快速移动到文件尾</td></tr><tr><td><code>0</code>(零)</td><td>将光标快速移动到行首</td></tr><tr><td><code>$</code></td><td>将光标快速移动到行尾</td></tr></tbody></table><a id="more"></a><h3 id="底线命令模式下"><a href="#底线命令模式下" class="headerlink" title="底线命令模式下"></a>底线命令模式下</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>:w</code>(<code>:w!</code>)</td><td>(强制)保存</td></tr><tr><td><code>:q</code>(<code>:q!</code>)</td><td>(强制)退出</td></tr><tr><td><code>:wq</code>(<code>:wq!</code>)/<code>:x</code>(<code>:x!</code>)</td><td>(强制)保存并退出</td></tr><tr><td><code>:</code> + 行号</td><td>定位到指定行</td></tr></tbody></table><h3 id="更多命令"><a href="#更多命令" class="headerlink" title="更多命令"></a><a href="http://www.runoob.com/linux/linux-vim.html" target="_blank" rel="noopener">更多命令</a></h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;vim 分为三种模式: 命令模式（Command mode）、输入模式（Insert mode）、底线命令模式（Last line mode），初始进入的是命令模式。&lt;/p&gt;
&lt;h3 id=&quot;命令模式下&quot;&gt;&lt;a href=&quot;#命令模式下&quot; class=&quot;headerlink&quot; title=&quot;命令模式下&quot;&gt;&lt;/a&gt;命令模式下&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;h&lt;/code&gt;/&lt;code&gt;j&lt;/code&gt;/&lt;code&gt;k&lt;/code&gt;/&lt;code&gt;l&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;←/↓/↑/→&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;:&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;切换到底线命令模式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;进入编辑模式，在光标后插入&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;i&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;进入编辑模式，在光标前插入&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;u&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;撤销，回到上一步操作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;dd&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;删除本行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;D&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;删除至行尾&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;w&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;下一个单词&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;b&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;上一个单词&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;e&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;光标到词尾&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;/&lt;/code&gt; + 内容&lt;/td&gt;
&lt;td&gt;查找内容，按&lt;code&gt;n&lt;/code&gt;跳到下一项&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&quot;编辑模式下&quot;&gt;&lt;a href=&quot;#编辑模式下&quot; class=&quot;headerlink&quot; title=&quot;编辑模式下&quot;&gt;&lt;/a&gt;编辑模式下&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;esc&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;进入命令模式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;g&lt;/code&gt; + &lt;code&gt;g&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;将光标快速移动到文件首&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;G&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;将光标快速移动到文件尾&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;0&lt;/code&gt;(零)&lt;/td&gt;
&lt;td&gt;将光标快速移动到行首&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;$&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;将光标快速移动到行尾&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
    
      <category term="other" scheme="https://hangermeng.top/tags/other/"/>
    
  </entry>
  
  <entry>
    <title>音标字母对应表</title>
    <link href="https://hangermeng.top/2018/10/13/%E9%9F%B3%E6%A0%87%E5%AD%97%E6%AF%8D%E5%AF%B9%E5%BA%94%E8%A1%A8/"/>
    <id>https://hangermeng.top/2018/10/13/音标字母对应表/</id>
    <published>2018-10-13T07:48:36.000Z</published>
    <updated>2021-01-19T06:42:29.043Z</updated>
    
    <content type="html"><![CDATA[<p>掌握了<a href="https://zhuanlan.zhihu.com/p/35702220" target="_blank" rel="noopener">音标</a>和其对应的字母（组合），就可以根据读音来拼写单词了。</p><a id="more"></a><h3 id="元音-20-个"><a href="#元音-20-个" class="headerlink" title="元音(20 个)"></a>元音(20 个)</h3><table><thead><tr><th>元音</th><th>字母（组合）</th></tr></thead><tbody><tr><td><code>[i:]</code></td><td><code>ee</code> <code>ea</code> <code>e</code> <code>ie</code></td></tr><tr><td><code>[i]</code></td><td><code>i</code> <code>y</code> <code>e</code></td></tr><tr><td><code>[æ]</code></td><td><code>a</code></td></tr><tr><td><code>[e]</code></td><td><code>ea</code> <code>e</code> <code>a</code></td></tr><tr><td><code>[ə:]</code></td><td><code>ir</code> <code>ur</code> <code>ear</code> <code>er</code> <code>or</code></td></tr><tr><td><code>[ə]</code></td><td><code>er</code> <code>or</code> <code>ou</code> <code>ar</code> <code>o</code> <code>a</code> <code>e</code> <code>u</code></td></tr><tr><td><code>[a:]</code></td><td><code>ar</code> <code>a</code></td></tr><tr><td><code>[۸]</code></td><td><code>u</code> <code>or</code> <code>ou</code> <code>oo</code></td></tr><tr><td><code>[כ:]</code></td><td><code>al</code> <code>or</code> <code>au</code> <code>our</code> <code>ar</code> <code>aw</code>(英音)</td></tr><tr><td><code>[כ]</code></td><td><code>o</code> <code>a</code> <code>aw</code>(美音)</td></tr><tr><td><code>[u:]</code></td><td><code>oo</code> <code>o</code> <code>u</code></td></tr><tr><td><code>[u]</code></td><td><code>oo</code> <code>ou</code> <code>o</code> <code>u</code></td></tr><tr><td><code>[ei]</code></td><td><code>a</code> <code>ay</code> <code>ea</code> <code>ai</code> <code>ey</code></td></tr><tr><td><code>[ai]</code></td><td><code>i</code> <code>y</code></td></tr><tr><td><code>[au]</code></td><td><code>ou</code> <code>ow</code></td></tr><tr><td><code>[əu]</code></td><td><code>o</code> <code>ow</code> <code>oa</code></td></tr><tr><td><code>[כi]</code></td><td><code>oy</code> <code>oi</code></td></tr><tr><td><code>[iə]</code></td><td><code>eer</code> <code>ea</code> <code>ear</code> <code>er</code> <code>ier</code></td></tr><tr><td><code>[eə]</code></td><td><code>ear</code> <code>air</code></td></tr><tr><td><code>[uə]</code></td><td><code>our</code> <code>oor</code></td></tr></tbody></table><h3 id="辅音-28-个"><a href="#辅音-28-个" class="headerlink" title="辅音(28 个)"></a>辅音(28 个)</h3><table><thead><tr><th>辅音</th><th>字母（组合）</th></tr></thead><tbody><tr><td><code>[k]</code></td><td><code>k</code> <code>c</code></td></tr><tr><td><code>[ŋ]</code></td><td><code>ng</code> <code>n</code></td></tr><tr><td><code>[j]</code></td><td><code>y</code></td></tr><tr><td><code>[f]</code></td><td><code>f</code> <code>gh</code> <code>ph</code></td></tr><tr><td><code>[θ]</code></td><td><code>th</code></td></tr><tr><td><code>[δ]</code></td><td><code>th</code></td></tr><tr><td><code>[∫]</code></td><td><code>sh</code> <code>tion</code> <code>cial</code></td></tr><tr><td><code>[з]</code></td><td><code>e</code></td></tr><tr><td><code>[t∫]</code></td><td><code>ch</code> <code>tch</code></td></tr><tr><td><code>[dз]</code></td><td><code>ge</code> <code>j</code></td></tr><tr><td><code>[dz]</code></td><td><code>ds</code></td></tr></tbody></table><p>其余辅音（<code>[p]</code> <code>[b]</code> <code>[t]</code> <code>[d]</code> <code>[g]</code> <code>[h]</code> <code>[r]</code> <code>[v]</code> <code>[s]</code> <code>[z]</code> <code>[w]</code> <code>[tr]</code> <code>[dr]</code> <code>[ts]</code> <code>[m]</code> <code>[n]</code> <code>[l]</code>）对应的字母为音标中显示的字母。</p><h3 id="百度文库"><a href="#百度文库" class="headerlink" title="百度文库"></a>百度文库</h3><ul><li><a href="https://wenku.baidu.com/view/debbe3eb19e8b8f67c1cb93b.html" target="_blank" rel="noopener">国际音标对应的字母组合</a></li><li><a href="https://wenku.baidu.com/view/e6b14f4d2e3f5727a5e9628d.html" target="_blank" rel="noopener">英语单词直接拼读法</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;掌握了&lt;a href=&quot;https://zhuanlan.zhihu.com/p/35702220&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;音标&lt;/a&gt;和其对应的字母（组合），就可以根据读音来拼写单词了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="English" scheme="https://hangermeng.top/tags/English/"/>
    
  </entry>
  
  <entry>
    <title>vscode使用心得</title>
    <link href="https://hangermeng.top/2018/10/03/vscode%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/"/>
    <id>https://hangermeng.top/2018/10/03/vscode使用心得/</id>
    <published>2018-10-03T01:59:28.000Z</published>
    <updated>2021-01-19T06:42:29.030Z</updated>
    
    <content type="html"><![CDATA[<h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td><code>command</code> + <code>k</code>, <code>command</code> + <code>s</code></td><td>弹出快捷键列表</td></tr><tr><td><code>option</code> + <code>command</code>+ <code>f</code></td><td>格式化文件</td></tr><tr><td><code>shift</code> + <code>command</code> + <code>k</code></td><td>删除当前行</td></tr><tr><td><code>shift</code> + <code>command</code> + <code>t</code></td><td>重新打开前一个关闭的编辑窗口</td></tr><tr><td><code>shift</code> + <code>command</code> + <code>[</code>/<code>]</code></td><td>切换到左侧/右侧 tab</td></tr><tr><td><code>command</code> + <code>[</code>/<code>]</code></td><td>向左/向右缩进当前行</td></tr><tr><td><code>command</code> + <code>i</code></td><td>选中当前行，再按合并选中下一行</td></tr><tr><td><code>command</code> + <code>k</code> + <code>m</code></td><td>更改文件语言</td></tr><tr><td><code>shift</code> + <code>option</code> + <code>↑</code>/<code>↓</code></td><td>上下复制当前行</td></tr><tr><td><code>option</code> + <code>↑</code>/<code>↓</code></td><td>上下移动当前行</td></tr><tr><td><code>shift</code> + <code>command</code> + <code>v</code></td><td>Markdown 预览</td></tr></tbody></table><a id="more"></a><h4 id="光标"><a href="#光标" class="headerlink" title="光标"></a>光标</h4><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td><code>command</code> + <code>↑</code>/<code>↓</code></td><td>跳转到页首/页尾</td></tr><tr><td><code>command</code> + <code>←</code>/<code>→</code></td><td>跳转到行首/行尾</td></tr><tr><td><code>option</code> + click</td><td>插入另一个光标</td></tr><tr><td><code>shift</code> + <code>option</code> + drag mouse（拖动鼠标）</td><td>列（框）选择</td></tr><tr><td><code>option</code> + <code>command</code> + <code>↑</code>/<code>↓</code></td><td>上下插入光标</td></tr><tr><td><code>shift</code> + <code>command</code> + <code>\</code></td><td>跳转到光标两侧的括号</td></tr><tr><td><code>command</code> + <code>u</code></td><td>撤销上一个光标</td></tr></tbody></table><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td><code>shift</code> + <code>command</code> + <code>h</code></td><td>在所有文件中替换</td></tr><tr><td><code>option</code> + <code>command</code> + <code>f</code></td><td>在当前文件中替换</td></tr><tr><td>(<code>shift</code> + )<code>command</code> + <code>f</code></td><td>在当前（所有）文件中查找</td></tr><tr><td>(<code>shift</code> +) <code>command</code> + <code>g</code></td><td>选择下一个（上一个）匹配项</td></tr><tr><td><code>option</code> + <code>enter</code></td><td>选择所有匹配项</td></tr><tr><td><code>command</code> + <code>d</code></td><td>选择下一个同名项</td></tr><tr><td><code>command</code> + <code>f2</code></td><td>选择所有同名项</td></tr></tbody></table><h4 id="编辑组"><a href="#编辑组" class="headerlink" title="编辑组"></a>编辑组</h4><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td><code>command</code> + <code>\</code></td><td>拆分编辑组</td></tr><tr><td><code>command</code> + <code>1</code></td><td>聚焦到当前编辑组下的第 1 个编辑窗口</td></tr><tr><td><code>command</code> + <code>k</code> + <code>←</code>/<code>→</code></td><td>将当前编辑组向左/向右移动</td></tr></tbody></table><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><ul><li>Bookmarks: 快速跳转到指定位置</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>在 vscode 中按下<code>shift</code>+<code>command</code>+<code>p</code>，输入<code>code</code>，选择<code>install &#39;code&#39; command in PATH</code>，之后就可以通过命令行<code>code xxx</code>，打开指定文件或文件夹（使用<code>code -h</code>查看所有命令）。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;快捷键&quot;&gt;&lt;a href=&quot;#快捷键&quot; class=&quot;headerlink&quot; title=&quot;快捷键&quot;&gt;&lt;/a&gt;快捷键&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;快捷键&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;command&lt;/code&gt; + &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;command&lt;/code&gt; + &lt;code&gt;s&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;弹出快捷键列表&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;option&lt;/code&gt; + &lt;code&gt;command&lt;/code&gt;+ &lt;code&gt;f&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;格式化文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;shift&lt;/code&gt; + &lt;code&gt;command&lt;/code&gt; + &lt;code&gt;k&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;删除当前行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;shift&lt;/code&gt; + &lt;code&gt;command&lt;/code&gt; + &lt;code&gt;t&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;重新打开前一个关闭的编辑窗口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;shift&lt;/code&gt; + &lt;code&gt;command&lt;/code&gt; + &lt;code&gt;[&lt;/code&gt;/&lt;code&gt;]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;切换到左侧/右侧 tab&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;command&lt;/code&gt; + &lt;code&gt;[&lt;/code&gt;/&lt;code&gt;]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;向左/向右缩进当前行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;command&lt;/code&gt; + &lt;code&gt;i&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;选中当前行，再按合并选中下一行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;command&lt;/code&gt; + &lt;code&gt;k&lt;/code&gt; + &lt;code&gt;m&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;更改文件语言&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;shift&lt;/code&gt; + &lt;code&gt;option&lt;/code&gt; + &lt;code&gt;↑&lt;/code&gt;/&lt;code&gt;↓&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;上下复制当前行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;option&lt;/code&gt; + &lt;code&gt;↑&lt;/code&gt;/&lt;code&gt;↓&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;上下移动当前行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;shift&lt;/code&gt; + &lt;code&gt;command&lt;/code&gt; + &lt;code&gt;v&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Markdown 预览&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
    
      <category term="vscode" scheme="https://hangermeng.top/tags/vscode/"/>
    
  </entry>
  
  <entry>
    <title>my bookmark</title>
    <link href="https://hangermeng.top/2018/07/04/my-bookmark/"/>
    <id>https://hangermeng.top/2018/07/04/my-bookmark/</id>
    <published>2018-07-04T14:17:21.000Z</published>
    <updated>2021-01-19T06:42:29.028Z</updated>
    
    <content type="html"><![CDATA[<h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p><a href="http://es6.ruanyifeng.com/#docs/proxy" target="_blank" rel="noopener">ECMAScript 6</a><br><a href="https://webpack.docschina.org/configuration/" target="_blank" rel="noopener">webpack</a><br><a href="https://www.tslang.cn/docs/handbook/interfaces.html" target="_blank" rel="noopener">TypeScript</a></p><h3 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h3><p><a href="http://www.ruanyifeng.com/blog/" target="_blank" rel="noopener">阮一峰</a><br><a href="http://taobaofed.org/" target="_blank" rel="noopener">淘宝-fed</a><br><a href="https://www.h5jun.com/" target="_blank" rel="noopener">十年踪迹</a><br><a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">廖雪峰</a></p><a id="more"></a><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><a href="https://jsbin.com/?html,output" target="_blank" rel="noopener">jsbin 在线页面代码测试</a><br><a href="http://xclient.info/" target="_blank" rel="noopener">xclient Mac应用分享</a><br><a href="http://www.iconfont.cn/" target="_blank" rel="noopener">iconfont 矢量图标库</a><br><a href="https://tinypng.com/" target="_blank" rel="noopener">tinypng 图片压缩</a><br><a href="https://tool.css-js.com/" target="_blank" rel="noopener">css-js 代码压缩</a><br><a href="https://portal.qiniu.com/" target="_blank" rel="noopener">qiniu 七牛云</a><br><a href="http://www.aigei.com/bgremover" target="_blank" rel="noopener">BgRemover 在线图片去底工具</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;文档&quot;&gt;&lt;a href=&quot;#文档&quot; class=&quot;headerlink&quot; title=&quot;文档&quot;&gt;&lt;/a&gt;文档&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/proxy&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ECMAScript 6&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://webpack.docschina.org/configuration/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;webpack&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.tslang.cn/docs/handbook/interfaces.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TypeScript&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;博客&quot;&gt;&lt;a href=&quot;#博客&quot; class=&quot;headerlink&quot; title=&quot;博客&quot;&gt;&lt;/a&gt;博客&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;阮一峰&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://taobaofed.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;淘宝-fed&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.h5jun.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;十年踪迹&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.liaoxuefeng.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;廖雪峰&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="bookmark" scheme="https://hangermeng.top/tags/bookmark/"/>
    
  </entry>
  
  <entry>
    <title>读《高效能人士的七个习惯》小记</title>
    <link href="https://hangermeng.top/2018/05/10/%E8%AF%BB%E3%80%8A%E9%AB%98%E6%95%88%E8%83%BD%E4%BA%BA%E5%A3%AB%E7%9A%84%E4%B8%83%E4%B8%AA%E4%B9%A0%E6%83%AF%E3%80%8B%E5%B0%8F%E8%AE%B0/"/>
    <id>https://hangermeng.top/2018/05/10/读《高效能人士的七个习惯》小记/</id>
    <published>2018-05-10T12:17:24.000Z</published>
    <updated>2021-01-19T06:42:29.042Z</updated>
    
    <content type="html"><![CDATA[<p>这七个习惯为：积极主动、以始为终、要事第一、双赢思维、知己解彼、统合综效、不断更新。前三个习惯实现独立，后三个习惯实现互赖。实现互赖的前提，是投资情感账户。</p><h4 id="积极主动"><a href="#积极主动" class="headerlink" title="积极主动"></a>积极主动</h4><p>积极主动的空间在于选择的权利，很多人不喜欢某门课是因为不喜欢授课老师，这意味着你把是否喜欢这门课的权利给了你的授课老师，这就是一种消极的表现，不断地把责任推卸给别人，放弃自己选择的权利。任何时候都要坚持选择的权利。<br>除去我们不关注的部分，世上的事情都处在我们的关注圈，其中我们能控制的部分就是影响圈。积极主动的人会把精力放在影响圈上，长此以往，他们的影响圈会逐渐扩大。<br><a id="more"></a></p><h4 id="以始为终"><a href="#以始为终" class="headerlink" title="以始为终"></a>以始为终</h4><p>把订定使命看得与行为本身同样重要，影响圈就会不断扩大。<br>不要以片面的目标（工作、家庭、金钱、享乐等）为中心，要以原则为生活中心。</p><h4 id="要事第一"><a href="#要事第一" class="headerlink" title="要事第一"></a>要事第一</h4><p>将重要不紧急的事情放在第一位，因为没有截止时间的催促，常常会一拖再拖，空闲的时间常常会被娱乐和琐事占用。在这个人生的木桶里，我们要装入沙子、大石子、小石子，只有先放大石子，再放小石子，最后放沙子，木桶才能放入更多的东西。<br>学会责任型授权，双方约定好预期结果，给予对方一些基于资源、陷阱的指导而非具体事项，明确责任和奖惩即可。</p><h4 id="双赢思维"><a href="#双赢思维" class="headerlink" title="双赢思维"></a>双赢思维</h4><p>顾及他人利益，维持合作关系，同时保持自己的原则。如果不能双赢就好聚好散。</p><h4 id="知己解彼"><a href="#知己解彼" class="headerlink" title="知己解彼"></a>知己解彼</h4><p>学会移情式聆听，带入倾诉者的角色去感受对方此番谈话的真正目的。避免价值判断、追根究底、好为人师、自以为是，避免使自己的体验去替代别人的体验，一副眼镜你戴的很舒服，但是给别人戴很可能是不舒服的。</p><h4 id="统合综效"><a href="#统合综效" class="headerlink" title="统合综效"></a>统合综效</h4><p>重视不同个体的不同想法，有分歧才有收获。遇到分歧时，不要急着妥协和对抗，要有信心找到第三种选择，创造的眼光重新审视问题。</p><h4 id="不断更新"><a href="#不断更新" class="headerlink" title="不断更新"></a>不断更新</h4><p>不断更新是一个螺旋式上升的过程，学习、实践、坚持。结合前六个习惯实现稳定而卓越的进步，包括身体、智力、精神、社会/感情。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这七个习惯为：积极主动、以始为终、要事第一、双赢思维、知己解彼、统合综效、不断更新。前三个习惯实现独立，后三个习惯实现互赖。实现互赖的前提，是投资情感账户。&lt;/p&gt;
&lt;h4 id=&quot;积极主动&quot;&gt;&lt;a href=&quot;#积极主动&quot; class=&quot;headerlink&quot; title=&quot;积极主动&quot;&gt;&lt;/a&gt;积极主动&lt;/h4&gt;&lt;p&gt;积极主动的空间在于选择的权利，很多人不喜欢某门课是因为不喜欢授课老师，这意味着你把是否喜欢这门课的权利给了你的授课老师，这就是一种消极的表现，不断地把责任推卸给别人，放弃自己选择的权利。任何时候都要坚持选择的权利。&lt;br&gt;除去我们不关注的部分，世上的事情都处在我们的关注圈，其中我们能控制的部分就是影响圈。积极主动的人会把精力放在影响圈上，长此以往，他们的影响圈会逐渐扩大。&lt;br&gt;
    
    </summary>
    
    
      <category term="books" scheme="https://hangermeng.top/tags/books/"/>
    
  </entry>
  
  <entry>
    <title>exec方法</title>
    <link href="https://hangermeng.top/2018/05/10/exec%E6%96%B9%E6%B3%95/"/>
    <id>https://hangermeng.top/2018/05/10/exec方法/</id>
    <published>2018-05-10T00:12:39.000Z</published>
    <updated>2021-01-19T06:42:29.024Z</updated>
    
    <content type="html"><![CDATA[<p>exec() 方法用于检索字符串中的正则表达式的匹配。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RegExpObject.exec(string)</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>string</td><td>必需。要检索的字符串。</td></tr></tbody></table><p>返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。<br><a id="more"></a></p><ul><li>此数组的第 0 个元素是与正则表达式相匹配的文本，第 1 个元素是与 RegExpObject 的第 1 个子表达式相匹配的文本（如果有的话），第 2 个元素是与 RegExpObject 的第 2 个子表达式相匹配的文本（如果有的话），以此类推。</li><li>除了数组元素和 length 属性之外，exec() 方法还返回两个属性。index 属性声明的是匹配文本的第一个字符的位置。input 属性则存放的是被检索的字符串 string。</li><li>在调用非全局的 RegExp 对象的 exec() 方法时，返回的数组与调用方法 String.match() 返回的数组是相同的。</li><li>但是，当 RegExpObject 是一个全局正则表达式时，exec() 的行为就稍微复杂一些。它会在 RegExpObject 的 lastIndex 属性指定的字符处开始检索字符串 string。当 exec() 找到了与表达式相匹配的文本时，在匹配后，它将把 RegExpObject 的 lastIndex 属性设置为匹配文本的最后一个字符的下一个位置。这就是说，您可以通过反复调用 exec() 方法来遍历字符串中的所有匹配文本。当 exec() 再也找不到匹配的文本时，它将返回 null，并把 lastIndex 属性重置为 0。</li></ul><p>注意：如果在一个字符串中完成了一次模式匹配之后要开始检索新的字符串，就必须手动地把 lastIndex 属性重置为 0。<br>无论 RegExpObject 是否是全局模式，exec() 都会把完整的细节添加到它返回的数组中。这就是 exec() 与 String.match() 的不同之处，后者在全局模式下返回的信息要少得多。因此我们可以这么说，在循环中反复地调用 exec() 方法是唯一一种获得全局模式的完整模式匹配信息的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tpl = <span class="string">'&lt;p&gt;Hello, my name is &lt;%this.name%&gt;. I\'m &lt;%this.age%&gt; years old.&lt;/p&gt;'</span>;</span><br><span class="line"><span class="keyword">var</span> re = <span class="regexp">/&lt;%([^%&gt;]+)?%&gt;/g</span>, match;</span><br><span class="line"><span class="keyword">while</span> (match = re.exec(tpl)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(match);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码输出如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"&lt;%this.name%&gt;"</span>, <span class="string">"this.name"</span>, <span class="attr">index</span>: <span class="number">21</span>, <span class="attr">input</span>: <span class="string">"&lt;p&gt;Hello, my name is &lt;%this.name%&gt;. I'm &lt;%this.age%&gt; years old.&lt;/p&gt;"</span>]</span><br><span class="line"></span><br><span class="line">[<span class="string">"&lt;%this.age%&gt;"</span>, <span class="string">"this.age"</span>, <span class="attr">index</span>: <span class="number">40</span>, <span class="attr">input</span>: <span class="string">"&lt;p&gt;Hello, my name is &lt;%this.name%&gt;. I'm &lt;%this.age%&gt; years old.&lt;/p&gt;"</span>]</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;exec() 方法用于检索字符串中的正则表达式的匹配。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;RegExpObject.exec(string)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;必需。要检索的字符串。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。&lt;br&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://hangermeng.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>match方法</title>
    <link href="https://hangermeng.top/2018/05/10/match%E6%96%B9%E6%B3%95/"/>
    <id>https://hangermeng.top/2018/05/10/match方法/</id>
    <published>2018-05-10T00:03:30.000Z</published>
    <updated>2021-01-19T06:42:29.027Z</updated>
    
    <content type="html"><![CDATA[<p>match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。该方法类似 indexOf() 和 lastIndexOf()，但是它返回指定的值，而不是字符串的位置。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stringObject.match(regexp)</span><br></pre></td></tr></table></figure></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>regexp</td><td>该参数可以是需要在 string 中检索的子串，也可以是需要检索的 RegExp 对象。</td></tr></tbody></table><p>返回一个存放匹配结果的数组。该数组的内容依赖于 regexp 是否具有全局标志 g。<br><a id="more"></a></p><ul><li>如果 regexp 没有标志 g，那么 match() 方法就只能在 stringObject 中执行一次匹配。如果没有找到任何匹配的文本， match() 将返回 null。否则，它将返回一个数组，其中存放了与它找到的匹配文本有关的信息。该数组的第 0 个元素存放的是匹配文本，而其余的元素存放的是与正则表达式的子表达式匹配的文本。除了这些常规的数组元素之外，返回的数组还含有两个对象属性。index 属性声明的是匹配文本的起始字符在 stringObject 中的位置，input 属性声明的是对 stringObject 的引用。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"1s plus 2s equal 3s"</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(<span class="regexp">/(\d+)s/</span>))</span><br><span class="line"><span class="comment">// ["1s", "1", index: 0, input: "1s plus 2s equal 3s", groups: undefined]</span></span><br></pre></td></tr></table></figure><ul><li>如果 regexp 具有标志 g，则 match() 方法将执行全局检索，找到 stringObject 中的所有匹配子字符串。若没有找到任何匹配的子串，则返回 null。如果找到了一个或多个匹配子串，则返回一个数组。不过全局匹配返回的数组的内容与前者大不相同，它的数组元素中存放的是 stringObject 中所有的匹配子串，而且也没有 index 属性或 input 属性。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">"1s plus 2s equal 3s"</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(<span class="regexp">/(\d+)s/g</span>))</span><br><span class="line"><span class="comment">// ["1s", "2s", "3s"]</span></span><br></pre></td></tr></table></figure><p>注意：在全局检索模式下，match() 即不提供与子表达式匹配的文本的信息，也不声明每个匹配子串的位置。如果您需要这些全局检索的信息，可以使用 <a href="https://hangermeng.top/2018/05/10/exec%E6%96%B9%E6%B3%95/#more">RegExp.exec()</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。该方法类似 indexOf() 和 lastIndexOf()，但是它返回指定的值，而不是字符串的位置。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;stringObject.match(regexp)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;regexp&lt;/td&gt;
&lt;td&gt;该参数可以是需要在 string 中检索的子串，也可以是需要检索的 RegExp 对象。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;返回一个存放匹配结果的数组。该数组的内容依赖于 regexp 是否具有全局标志 g。&lt;br&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://hangermeng.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>暴雨欲来</title>
    <link href="https://hangermeng.top/2018/05/09/%E6%9A%B4%E9%9B%A8%E6%AC%B2%E6%9D%A5/"/>
    <id>https://hangermeng.top/2018/05/09/暴雨欲来/</id>
    <published>2018-05-09T01:49:10.000Z</published>
    <updated>2021-01-19T06:42:29.040Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;阳光明媚如佛光倾洒于世间，蝉声响亮如夏雨敲打在芭蕉，长江以南西湖以北，一个科技园的平房里有一群年轻人坐在电脑前做着各种各样的事情，想着各自不为人知的秘密，等待着固定工作时间的结尾。<a id="more"></a><br>&emsp;&emsp;空调送来清凉的气息，滋润着这个渺小的空间，就好像阳光滋润着向日葵。盛夏的四点多依旧是散发着蓬勃的热气，衬托出室内的舒爽，一双双晶亮的眼眸仿佛在期待晚风的到来，夏天最舒服的莫过于夜晚的凉风，褪去了白日的炎炎之火，带来夜晚温柔的暗香。<br>&emsp;&emsp;孤独的许多人聚在一起，漂泊在这异地他乡，为了更好地将生活书写。也不知道是否还记得当年的骑着巨龙挥着剑的勇士，踏着火焰而来，驾着热浪而去，坚守在自己的梦想乡，一砖砖的一瓦瓦的建造属于自己的城堡，周围绿色的小山如碧波暗涌的大海，远处高山弥漫着丝丝的云雾，仿佛住着一个仙人老爷爷，还有一个总是缠在他身边撒娇的乖巧孙女，他们现在刚砍完柴，走在回家的路上。<br>&emsp;&emsp;每天早晨四五点钟的时候静静地坐在城堡的天台，安静地等待太阳的到来，当黑幕开始泛白，露出微微的亮光，温和的光线如此亲切。渐渐地看见了远处一条闪亮的小河，如一条银色的腰带系在绿色的连衣裙上。太阳越来越大了，目光凝视远方的天幕，期待着此时从天边飞来一个人，宛如天上仙子，身姿如幽幽湖水泛起柔美的光晕，当一抹笑容展开，透着满满的善良与快乐，骑士孤独的世界瞬间染上了缤纷烂漫的色彩。在一个美好的日子，遇见美好的姑娘，收起手中的荣耀之剑，归隐山林的城堡，从此只问柴米油盐，不问世事是非。多么美好的故事，多么美好的朝霞，多么美好的姑娘。如果上天有灵的话，一定会如此的安排吧。<br>&emsp;&emsp;多少个夜晚，一个人一头龙休息在滚滚的篝火旁，梦里自己正在解救一个受难的村庄，驾着巨龙翱翔天际，龙口中的火焰焚尽一切污秽的东西。<br>&emsp;&emsp;猛然间一股凉风将梦境打碎，悬崖，峭壁，孤木，一轮圆月如银盘。浪子漂泊在外，慈母牵挂在心。奈何好儿郎始终有一个骑龙仗剑的梦萦绕左右，剑终究是要自从坚硬的石缝之中拔出来的，龙中怒气终究是要化作炙热的火焰喷薄而出的。<br>&emsp;&emsp;天开始阴沉，忽然间雷声阵阵，一场倾盆大雨在所难免。母亲倚靠在门口仰望天空，像是在担心什么。<br>&emsp;&emsp;漂泊在外的人儿啊，当狂风暴雨再次响起的时候，你是否仍然有一种坚韧无比的勇气来面对苦难，即使前路漫漫，雨打湿了衣裳。</p><blockquote><p><em>语寺</em><br><em>2016.7</em></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;阳光明媚如佛光倾洒于世间，蝉声响亮如夏雨敲打在芭蕉，长江以南西湖以北，一个科技园的平房里有一群年轻人坐在电脑前做着各种各样的事情，想着各自不为人知的秘密，等待着固定工作时间的结尾。
    
    </summary>
    
    
      <category term="writing" scheme="https://hangermeng.top/tags/writing/"/>
    
  </entry>
  
  <entry>
    <title>沉默</title>
    <link href="https://hangermeng.top/2018/05/06/%E6%B2%89%E9%BB%98/"/>
    <id>https://hangermeng.top/2018/05/06/沉默/</id>
    <published>2018-05-06T11:28:08.000Z</published>
    <updated>2021-01-19T06:42:29.041Z</updated>
    
    <content type="html"><![CDATA[<p>缓缓走过小区四幢<br>二楼的落地窗前伫立着一只白色卷毛小狗<br>宛如一尊雕像静静地望着窗外<br>路边有条小狗正活蹦乱跳</p><a id="more"></a><p>阴沉的天空<br>经历了昨日一整天的大雨<br>布满朵朵低压的乌云<br>某处缝隙中透出美丽的金色光芒</p><p>那束阳光为了到达人间<br>走过了遥远的距离<br>但是现在再也无法前进了<br>唯有你敞开心扉<br>才能传递光与热</p><p>然而我在屋外等了很久很久<br>但是立夏的夜晚并没有任何问候<br>只有淅淅沥沥地落雨<br>安静<br>一如既往</p><p>渐渐地<br>炽热的心脏开始冷却<br>屋内的小狗<br>转身离开了窗台</p><p>我听闻最可笑的故事<br>是结局沉默了<br>曾经立誓不再做梦的少年<br>又一次醒了</p><blockquote><p><em>语寺</em><br><em>2018.5.6</em></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;缓缓走过小区四幢&lt;br&gt;二楼的落地窗前伫立着一只白色卷毛小狗&lt;br&gt;宛如一尊雕像静静地望着窗外&lt;br&gt;路边有条小狗正活蹦乱跳&lt;/p&gt;
    
    </summary>
    
    
      <category term="writing" scheme="https://hangermeng.top/tags/writing/"/>
    
  </entry>
  
</feed>
